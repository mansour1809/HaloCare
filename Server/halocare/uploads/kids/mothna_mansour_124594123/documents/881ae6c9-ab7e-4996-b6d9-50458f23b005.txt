// src/pages/kids/KidsManagement.jsx 
import React, { useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { 
  Box, Typography, Paper, Table, TableBody, TableCell, TableContainer, 
  TableHead, TableRow, Avatar, Button, IconButton, TextField, InputAdornment,
  CircularProgress, Alert, Chip, Breadcrumbs, FormControl, InputLabel, 
  Select, MenuItem, Tooltip, Card, CardContent, Grid, LinearProgress, Fab
} from '@mui/material';
import { 
  Add as AddIcon, Search as SearchIcon, Visibility as VisibilityIcon,
  Home as HomeIcon, Group as GroupIcon, Refresh as RefreshIcon,
  PlayArrow as StartIcon, Edit as EditIcon, CheckCircle as CompleteIcon,
  Dashboard as DashboardIcon, Email as EmailIcon
} from '@mui/icons-material';

import { fetchKids } from '../../Redux/features/kidsSlice';
import { fetchOnboardingStatus } from '../../Redux/features/onboardingSlice';
import Swal from 'sweetalert2';

// ×§×•××¤×•× × ×˜×” ×œ×‘××“×’' ×¡×˜×˜×•×¡ ××¢×•×“×›×Ÿ
const OnboardingStatusChip = ({ onboardingData }) => {
  if (!onboardingData) {
    return (
      <Chip
        label="â—‹ ×œ× ×”×ª×—×™×œ"
        color="default"
        variant="outlined"
        size="small"
        sx={{ fontWeight: 'medium', minWidth: '120px' }}
      />
    );
  }

  const { process, completionPercentage, completedForms, totalForms } = onboardingData;
  
  const getStatusConfig = () => {
    switch (process.processStatus) {
      case 'Completed':
        return { 
          color: 'success', 
          label: `âœ… ×”×•×©×œ× (${completedForms}/${totalForms})`, 
          variant: 'filled' 
        };
      case 'InProgress':
        return { 
          color: 'primary', 
          label: `âš¡ ×‘×ª×”×œ×™×š (${completionPercentage}%)`, 
          variant: 'filled' 
        };
      default:
        return { 
          color: 'info', 
          label: 'ğŸš€ ×”×ª×—×™×œ', 
          variant: 'filled' 
        };
    }
  };

  const config = getStatusConfig();
  
  return (
    <Chip
      label={config.label}
      color={config.color}
      variant={config.variant}
      size="small"
      sx={{ fontWeight: 'medium', minWidth: '120px' }}
    />
  );
};

// ×§×•××¤×•× × ×˜×” ××¢×•×“×›× ×ª ×œ×¤×¢×•×œ×•×ª
const OnboardingActions = ({ kid, onboardingData, onAction }) => {
  const getActions = () => {
    if (!onboardingData) {
      return [
        { 
          action: 'start', 
          label: '×”×ª×—×œ ×§×œ×™×˜×”', 
          color: 'primary', 
          icon: <StartIcon />,
          tooltip: '×”×ª×—×œ ×ª×”×œ×™×š ×§×œ×™×˜×” ×—×“×©'
        }
      ];
    }

    const { process } = onboardingData;

    switch (process.processStatus) {
      case 'InProgress':
        return [
          { 
            action: 'dashboard', 
            label: '×××©×§', 
            color: 'primary', 
            icon: <DashboardIcon />,
            tooltip: '×¤×ª×— ×××©×§ × ×™×”×•×œ ×”×§×œ×™×˜×”'
          }
        ];
      case 'Completed':
        return [
          { 
            action: 'dashboard', 
            label: '×¦×¤×”', 
            color: 'success', 
            icon: <VisibilityIcon />,
            tooltip: '×¦×¤×” ×‘×¡×˜×˜×•×¡ ×”×§×œ×™×˜×”'
          }
        ];
      default:
        return [
          { 
            action: 'start', 
            label: '×”×ª×—×œ', 
            color: 'primary', 
            icon: <StartIcon />,
            tooltip: '×”×ª×—×œ ×ª×”×œ×™×š ×§×œ×™×˜×”'
          }
        ];
    }
  };

  const actions = getActions();

  return (
    <Box sx={{ display: 'flex', gap: 0.5 }}>
      {actions.map((actionConfig) => (
        <Tooltip key={actionConfig.action} title={actionConfig.tooltip}>
          <IconButton
            size="small"
            onClick={() => onAction(actionConfig.action, kid.id)}
            sx={{
              backgroundColor: `${actionConfig.color}.main`,
              color: 'white',
              '&:hover': {
                backgroundColor: `${actionConfig.color}.dark`,
              }
            }}
          >
            {actionConfig.icon}
          </IconButton>
        </Tooltip>
      ))}
      
      {/* ×›×¤×ª×•×¨ ×¦×¤×™×™×” ×‘×¤×¨×•×¤×™×œ ×ª××™×“ ×–××™×Ÿ */}
      <Tooltip title="×¦×¤×™×™×” ×‘×¤×¨×•×¤×™×œ ×”×™×œ×“">
        <IconButton
          size="small"
          onClick={() => onAction('profile', kid.id)}
          sx={{
            backgroundColor: 'info.main',
            color: 'white',
            '&:hover': {
              backgroundColor: 'info.dark',
            }
          }}
        >
          <VisibilityIcon />
        </IconButton>
      </Tooltip>
    </Box>
  );
};

// ×§×•××¤×•× × ×˜×” ×—×“×©×” ×œ×”×¦×’×ª ×”×ª×§×“××•×ª ××¤×•×¨×˜×ª
const DetailedProgress = ({ onboardingData }) => {
  if (!onboardingData || !onboardingData.forms) {
    return <Typography variant="body2" color="text.secondary">â€“</Typography>;
  }

  const { forms, completionPercentage } = onboardingData;
  
  // ×¡×¤×™×¨×ª ×¡×˜×˜×•×¡×™×
  const statusCounts = forms.reduce((acc, form) => {
    const status = form.status;
    if (status === 'completed' || status === 'completed_by_parent') {
      acc.completed++;
    } else if (status === 'in_progress') {
      acc.inProgress++;
    } else if (status === 'sent_to_parent') {
      acc.sentToParent++;
    } else {
      acc.notStarted++;
    }
    return acc;
  }, { completed: 0, inProgress: 0, sentToParent: 0, notStarted: 0 });

  return (
    <Box sx={{ minWidth: 150 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
        <LinearProgress 
          variant="determinate" 
          value={completionPercentage} 
          sx={{ width: 100, height: 8, borderRadius: 4 }}
        />
        <Typography variant="body2" fontWeight="bold">
          {completionPercentage}%
        </Typography>
      </Box>
      
      <Box sx={{ display: 'flex', gap: 0.5, flexWrap: 'wrap' }}>
        {statusCounts.completed > 0 && (
          <Chip 
            label={`âœ… ${statusCounts.completed}`} 
            size="small" 
            color="success" 
            variant="outlined"
          />
        )}
        {statusCounts.inProgress > 0 && (
          <Chip 
            label={`âš¡ ${statusCounts.inProgress}`} 
            size="small" 
            color="primary" 
            variant="outlined"
          />
        )}
        {statusCounts.sentToParent > 0 && (
          <Chip 
            label={`ğŸ“§ ${statusCounts.sentToParent}`} 
            size="small" 
            color="info" 
            variant="outlined"
          />
        )}
      </Box>
    </Box>
  );
};

const KidsManagement = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  
  const { kids, status, error } = useSelector(state => state.kids);
  
  const [searchTerm, setSearchTerm] = useState('');
  const [statusFilter, setStatusFilter] = useState('');
  const [onboardingData, setOnboardingData] = useState({});
  const [loading, setLoading] = useState(false);

  // ×˜×¢×™× ×” ×¨××©×•× ×™×ª
  useEffect(() => {
    loadData();
  }, [dispatch]);

  const loadData = async () => {
    setLoading(true);
    try {
      // ×˜×¢×™× ×ª ×¨×©×™××ª ×™×œ×“×™×
      const kidsResult = await dispatch(fetchKids()).unwrap();
      
      // ×˜×¢×™× ×ª × ×ª×•× ×™ ×§×œ×™×˜×” ×œ×›×œ ×™×œ×“
      const onboardingPromises = kidsResult.map(async (kid) => {
        try {
          const statusResult = await dispatch(fetchOnboardingStatus(kid.id)).unwrap();
          return { kidId: kid.id, data: statusResult };
        } catch (error) {
          // ××™×Ÿ ×ª×”×œ×™×š ×§×œ×™×˜×” - ×”×—×–×¨ null
          return { kidId: kid.id, data: null };
        }
      });
      
      const onboardingResults = await Promise.all(onboardingPromises);
      const onboardingMap = {};
      onboardingResults.forEach(({ kidId, data }) => {
        onboardingMap[kidId] = data;
      });
      
      setOnboardingData(onboardingMap);
      
    } catch (error) {
      console.error('Error loading data:', error);
      Swal.fire({
        icon: 'error',
        title: '×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™×',
        text: error.message || '××™×¨×¢×” ×©×’×™××” ×‘×˜×¢×™× ×ª ×”× ×ª×•× ×™×'
      });
    } finally {
      setLoading(false);
    }
  };

  // ×¨×¢× ×•×Ÿ × ×ª×•× ×™×
  const handleRefresh = () => {
    loadData();
  };

  // ×˜×™×¤×•×œ ×‘×¤×¢×•×œ×•×ª
  const handleAction = (action, kidId) => {
    switch (action) {
      case 'start':
        navigate(`/kids/onboarding/${kidId}`);
        break;
      case 'dashboard':
        navigate(`/kids/onboarding/${kidId}`);
        break;
      case 'profile':
        navigate(`/kids/${kidId}`);
        break;
      default:
        console.log(`Action ${action} not implemented yet`);
    }
  };

  // ×—×™×©×•×‘ ×’×™×œ
  const calculateAge = (birthDateString) => {
    if (!birthDateString) return 'â€“';
    const birthDate = new Date(birthDateString);
    const today = new Date();
    const years = today.getFullYear() - birthDate.getFullYear();
    const months = today.getMonth() - birthDate.getMonth();
    
    if (years > 0) {
      return `${years} ×©× ×™×`;
    } else {
      return `${months >= 0 ? months : months + 12} ×—×•×“×©×™×`;
    }
  };

  // ×¤×™×œ×˜×•×¨ ×™×œ×“×™×
  const filteredKids = kids.filter(kid => {
    const searchMatch = !searchTerm || 
      (kid.firstName && kid.firstName.toLowerCase().includes(searchTerm.toLowerCase())) ||
      (kid.lastName && kid.lastName.toLowerCase().includes(searchTerm.toLowerCase()));
    
    const kidOnboardingData = onboardingData[kid.id];
    const processStatus = kidOnboardingData?.process?.processStatus || 'NotStarted';
    const statusMatch = !statusFilter || processStatus === statusFilter;
    
    return searchMatch && statusMatch;
  });

  // ×—×™×©×•×‘ ×¡×˜×˜×™×¡×˜×™×§×•×ª ××¢×•×“×›×Ÿ
  const stats = {
    total: kids.length,
    completed: Object.values(onboardingData).filter(d => d?.process?.processStatus === 'Completed').length,
    inProgress: Object.values(onboardingData).filter(d => d?.process?.processStatus === 'InProgress').length,
    notStarted: kids.length - Object.keys(onboardingData).filter(k => onboardingData[k]).length
  };

  return (
    <Box sx={{ p: 3 }} dir="rtl">
      {/* Breadcrumbs */}
      <Breadcrumbs sx={{ mb: 2 }}>
        <Box 
          sx={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}
          onClick={() => navigate('/')}
        >
          <HomeIcon sx={{ mr: 0.5, fontSize: 'small' }} />
          ×¨××©×™
        </Box>
        <Typography color="text.primary" sx={{ display: 'flex', alignItems: 'center' }}>
          <GroupIcon sx={{ mr: 0.5, fontSize: 'small' }} />
          × ×™×”×•×œ ×™×œ×“×™×
        </Typography>
      </Breadcrumbs>
      
      {/* ×›×•×ª×¨×ª ×•×¤×¢×•×œ×•×ª */}
      <Paper sx={{ p: 3, mb: 3, borderRadius: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Box>
            <Typography variant="h4" sx={{ fontWeight: 'bold', color: 'primary.main', mb: 1 }}>
              × ×™×”×•×œ ×™×œ×“×™×
            </Typography>
            <Typography variant="body1" color="text.secondary">
              ××¢×§×‘ ××—×¨ ×ª×”×œ×™×›×™ ×§×œ×™×˜×” ×•× ×™×”×•×œ ×¤×¨×˜×™ ×™×œ×“×™× ×‘××¢×¨×›×ª
            </Typography>
          </Box>
          
          <Box sx={{ display: 'flex', gap: 2 }}>
            <Tooltip title="×¨×¢× ×•×Ÿ × ×ª×•× ×™×">
              <IconButton onClick={handleRefresh} disabled={loading}>
                <RefreshIcon />
              </IconButton>
            </Tooltip>
            
            <Button
              variant="contained"
              startIcon={<AddIcon />}
              onClick={() => navigate('/kids/onboarding/new')}
            >
              ×§×œ×™×˜×ª ×™×œ×“ ×—×“×©
            </Button>
          </Box>
        </Box>
        
        {/* ×¤×™×œ×˜×¨×™× */}
        <Box sx={{ display: 'flex', gap: 2, mb: 2 }}>
          <TextField
            size="small"
            placeholder="×—×™×¤×•×© ×œ×¤×™ ×©×..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon />
                </InputAdornment>
              ),
            }}
            sx={{ width: 300 }}
          />
          
          <FormControl size="small" sx={{ minWidth: 200 }}>
            <InputLabel>×¡×˜×˜×•×¡ ×ª×”×œ×™×š</InputLabel>
            <Select
              value={statusFilter}
              onChange={(e) => setStatusFilter(e.target.value)}
              label="×¡×˜×˜×•×¡ ×ª×”×œ×™×š"
            >
              <MenuItem value="">×”×›×œ</MenuItem>
              <MenuItem value="NotStarted">×œ× ×”×ª×—×™×œ</MenuItem>
              <MenuItem value="InProgress">×‘×ª×”×œ×™×š</MenuItem>
              <MenuItem value="Completed">×”×•×©×œ×</MenuItem>
            </Select>
          </FormControl>
        </Box>
      </Paper>

      {/* ×¡×˜×˜×™×¡×˜×™×§×•×ª */}
      <Grid container spacing={2} sx={{ mb: 3 }}>
        <Grid item xs={12} sm={3}>
          <Card sx={{ textAlign: 'center', p: 2 }}>
            <Typography variant="h3" color="primary.main" fontWeight="bold">
              {stats.total}
            </Typography>
            <Typography variant="body2" color="text.secondary">
              ×¡×”"×› ×™×œ×“×™×
            </Typography>
          </Card>
        </Grid>
        <Grid item xs={12} sm={3}>
          <Card sx={{ textAlign: 'center', p: 2 }}>
            <Typography variant="h3" color="success.main" fontWeight="bold">
              {stats.completed}
            </Typography>
            <Typography variant="body2" color="text.secondary">
              ×”×•×©×œ××•
            </Typography>
          </Card>
        </Grid>
        <Grid item xs={12} sm={3}>
          <Card sx={{ textAlign: 'center', p: 2 }}>
            <Typography variant="h3" color="warning.main" fontWeight="bold">
              {stats.inProgress}
            </Typography>
            <Typography variant="body2" color="text.secondary">
              ×‘×ª×”×œ×™×š
            </Typography>
          </Card>
        </Grid>
        <Grid item xs={12} sm={3}>
          <Card sx={{ textAlign: 'center', p: 2 }}>
            <Typography variant="h3" color="info.main" fontWeight="bold">
              {stats.notStarted}
            </Typography>
            <Typography variant="body2" color="text.secondary">
              ×œ× ×”×ª×—×™×œ×•
            </Typography>
          </Card>
        </Grid>
      </Grid>

      {/* ×©×’×™××•×ª */}
      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      {/* ×˜×‘×œ×ª ×™×œ×“×™× */}
      <TableContainer component={Paper} sx={{ borderRadius: 3 }}>
        <Table>
          <TableHead>
            <TableRow sx={{ backgroundColor: 'grey.50' }}>
              <TableCell sx={{ fontWeight: 700 }}>×™×œ×“</TableCell>
              <TableCell sx={{ fontWeight: 700 }}>×’×™×œ</TableCell>
              <TableCell sx={{ fontWeight: 700 }}>××’×“×¨</TableCell>
              <TableCell sx={{ fontWeight: 700 }}>×”×•×¨×” ×¨××©×™</TableCell>
              <TableCell sx={{ fontWeight: 700 }}>×¡×˜×˜×•×¡ ×§×œ×™×˜×”</TableCell>
              <TableCell sx={{ fontWeight: 700 }}>×”×ª×§×“××•×ª ××¤×•×¨×˜×ª</TableCell>
              <TableCell sx={{ fontWeight: 700 }}>×¤×¢×•×œ×•×ª</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {loading ? (
              <TableRow>
                <TableCell colSpan={7} align="center" sx={{ py: 4 }}>
                  <CircularProgress />
                </TableCell>
              </TableRow>
            ) : filteredKids.length === 0 ? (
              <TableRow>
                <TableCell colSpan={7} align="center" sx={{ py: 4 }}>
                  <Typography color="text.secondary">
                    ×œ× × ××¦××• ×™×œ×“×™×
                  </Typography>
                </TableCell>
              </TableRow>
            ) : (
              filteredKids.map((kid) => {
                const kidOnboardingData = onboardingData[kid.id];
                
                return (
                  <TableRow key={kid.id} hover>
                    <TableCell>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                        <Avatar sx={{ width: 40, height: 40 }}>
                          {`${kid.firstName?.[0] || ''}${kid.lastName?.[0] || ''}`}
                        </Avatar>
                        <Typography fontWeight="medium">
                          {`${kid.firstName || ''} ${kid.lastName || ''}`}
                        </Typography>
                      </Box>
                    </TableCell>
                    <TableCell>{calculateAge(kid.birthDate)}</TableCell>
                    <TableCell>
                      <Chip 
                        label={kid.gender === '×–×›×¨' ? '×–×›×¨' : '× ×§×‘×”'} 
                        size="small"
                        color={kid.gender === '×–×›×¨' ? 'primary' : 'secondary'}
                      />
                    </TableCell>
                    <TableCell>{kid.parentName1 || 'â€“'}</TableCell>
                    <TableCell>
                      <OnboardingStatusChip onboardingData={kidOnboardingData} />
                    </TableCell>
                    <TableCell>
                      <DetailedProgress onboardingData={kidOnboardingData} />
                    </TableCell>
                    <TableCell>
                      <OnboardingActions
                        kid={kid}
                        onboardingData={kidOnboardingData}
                        onAction={handleAction}
                      />
                    </TableCell>
                  </TableRow>
                );
              })
            )}
          </TableBody>
        </Table>
      </TableContainer>

      {/* ×›×¤×ª×•×¨ ×¦×£ */}
      <Fab
        color="primary"
        onClick={() => navigate('/kids/onboarding/new')}
        sx={{ position: 'fixed', bottom: 24, left: 24 }}
      >
        <AddIcon />
      </Fab>
    </Box>
  );
};

export default KidsManagement;

#################################################################

// src/pages/kids/KidOnboarding.jsx - ×’×¨×¡×” ××¢×•×“×›× ×ª ×¢× Dashboard
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useDispatch, useSelector } from 'react-redux';
import {
  Container, Box, Paper, Typography, CircularProgress, Breadcrumbs,
  Button, Alert, AlertTitle, Fade, Dialog, DialogTitle, DialogContent,
  DialogActions
} from '@mui/material';
import {
  Home as HomeIcon,
  Group as GroupIcon,
  ArrowBack as BackIcon,
  Refresh as RefreshIcon
} from '@mui/icons-material';

import { 
  fetchOnboardingStatus, 
  fetchAvailableForms, 
  clearOnboardingData,
  setCurrentProcess
} from '../../Redux/features/onboardingSlice';
import { 
  fetchKidById, 
  clearSelectedKid
} from '../../Redux/features/kidsSlice';
import PersonalInfoForm from './PersonalInfoForm';
import DynamicFormRenderer from './DynamicFormRenderer';
import OnboardingDashboard from './OnboardingDashboard';
import ProgressLogo from './ProgressLogo';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';

const KidOnboarding = () => {
  const { kidId } = useParams();
  const navigate = useNavigate();
  const dispatch = useDispatch();
  
  const { currentProcess, status, error } = useSelector(state => state.onboarding);
  const { selectedKid } = useSelector(state => state.kids);
  
  const [viewMode, setViewMode] = useState('dashboard'); // 'dashboard' | 'form'
  const [selectedForm, setSelectedForm] = useState(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const isNewKid = kidId === undefined ;

  // ×˜×¢×™× ×” ×¨××©×•× ×™×ª
  useEffect(() => {
    initializeOnboarding();
  }, [kidId]);

  const initializeOnboarding = async () => {
    try {
      setLoading(true);
      dispatch(clearOnboardingData());
      dispatch(clearSelectedKid());
      
      if (!isNewKid) {
        // ×˜×¢×™× ×ª × ×ª×•× ×™ ×™×œ×“ ×§×™×™×
        await dispatch(fetchKidById(kidId));
        
        // ×˜×¢×™× ×ª ×¡×˜×˜×•×¡ ×”×ª×”×œ×™×š
        try {
          const statusResult = await dispatch(fetchOnboardingStatus(kidId)).unwrap();
          dispatch(setCurrentProcess(kidId));
          setViewMode('dashboard');
        } catch (error) {
          console.log('No onboarding process found, showing form creation');
          // ××™×Ÿ ×ª×”×œ×™×š ×§×œ×™×˜×” - ××¦×™×’×™× ×”×•×“×¢×”
        }
      } else {
        // ×™×œ×“ ×—×“×© - ×”×¦×’×ª ×˜×•×¤×¡ ×¤×¨×˜×™× ××™×©×™×™×
        setViewMode('personalInfo');
      }
      
    } catch (error) {
      console.error('Error initializing onboarding:', error);
    } finally {
      setLoading(false);
    }
  };

  // ×¨×¢× ×•×Ÿ × ×ª×•× ×™×
  const handleRefresh = async () => {
    if (isNewKid) return;
    
    setRefreshing(true);
    try {
      await dispatch(fetchOnboardingStatus(kidId)).unwrap();
      dispatch(setCurrentProcess(kidId));
    } catch (error) {
      console.error('Error refreshing data:', error);
    } finally {
      setRefreshing(false);
    }
  };

  // ×§×œ×™×˜×ª ×™×œ×“ ×—×“×© ×”×•×©×œ××”
  const handleKidCreated = (newKid) => {
    navigate(`/kids/onboarding/${newKid.id}`, { replace: true });
    // ×”×˜×¢×™× ×” ×”×—×“×©×” ×ª×ª×¨×—×© ×‘-useEffect
  };

  // ×‘×—×™×¨×ª ×˜×•×¤×¡ ×œ×¢×¨×™×›×”
  const handleFormSelect = (form) => {
    setSelectedForm(form);
    setViewMode('form');
  };

  // ×”×©×œ××ª ×˜×•×¤×¡
  const handleFormComplete = async (formId) => {
    setViewMode('dashboard');
    setSelectedForm(null);
    await handleRefresh(); // ×¨×¢× ×•×Ÿ ×”× ×ª×•× ×™×
  };

  // ×—×–×¨×” ×œ-Dashboard
  const handleBackToDashboard = () => {
    setViewMode('dashboard');
    setSelectedForm(null);
  };

  // ×©×œ×™×—×” ×œ×”×•×¨×™×
  const handleSendToParent = (form) => {
    // ×”×¤×¢×•×œ×” ××ª×‘×¦×¢×ª ×‘-OnboardingDashboard
    console.log('Form sent to parent:', form);
  };

  if (loading) {
    return (
      <Container maxWidth="md" sx={{ py: 4, textAlign: 'center' }}>
        <CircularProgress size={60} />
        <Typography variant="h6" sx={{ mt: 2 }}>
          ×˜×•×¢×Ÿ ×ª×”×œ×™×š ×§×œ×™×˜×”...
        </Typography>
      </Container>
    );
  }

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Container maxWidth="lg" sx={{ py: 4 }}>
        {/* Breadcrumbs */}
        <Breadcrumbs sx={{ mb: 3 }}>
          <Box 
            sx={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}
            onClick={() => navigate('/')}
          >
            <HomeIcon sx={{ mr: 0.5 }} />
            ×¨××©×™
          </Box>
          <Box 
            sx={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}
            onClick={() => navigate('/kids')}
          >
            <GroupIcon sx={{ mr: 0.5 }} />
            × ×™×”×•×œ ×™×œ×“×™×
          </Box>
          <Typography color="text.primary">
            {isNewKid ? '×§×œ×™×˜×ª ×™×œ×“ ×—×“×©' : `×§×œ×™×˜×” - ${selectedKid?.firstName} ${selectedKid?.lastName}`}
          </Typography>
        </Breadcrumbs>

        {/* ×©×’×™××•×ª */}
        {error && (
          <Alert severity="error" sx={{ mb: 3 }}>
            <AlertTitle>×©×’×™××”</AlertTitle>
            {error}
          </Alert>
        )}

        {/* ×”×œ×•×’×• ×¢× ×”×¤×¨×•×’×¨×¡ */}
        {!isNewKid && currentProcess && (
          <ProgressLogo 
            onboardingData={currentProcess}
            kidName={selectedKid ? `${selectedKid.firstName} ${selectedKid.lastName}` : null}
            showFormsSummary={viewMode === 'dashboard'}
            compact={viewMode !== 'dashboard'}
          />
        )}

        {/* ×ª×•×›×Ÿ ×“×™× ××™ ×œ×¤×™ ××¦×‘ */}
        <Fade in={true} timeout={500}>
          <Box>
            {viewMode === 'personalInfo' && (
              <Paper sx={{ borderRadius: 3, overflow: 'hidden', mb: 3 }}>
                <Box sx={{ p: 3, backgroundColor: 'grey.50' }}>
                  <Typography variant="h5" gutterBottom>
                    ×¤×¨×˜×™× ××™×©×™×™×
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    ××™×œ×•×™ ×¤×¨×˜×™ ×”×™×œ×“ ×•×”×”×•×¨×™×
                  </Typography>
                </Box>
                
                <Box sx={{ p: 3 }}>
                  <PersonalInfoForm
                    data={null}
                    onUpdate={handleKidCreated}
                    isEditMode={false}
                  />
                </Box>
              </Paper>
            )}

            {viewMode === 'dashboard' && currentProcess && (
              <>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                  <Typography variant="h4" fontWeight="bold">
                    ×ª×”×œ×™×š ×§×œ×™×˜×”
                  </Typography>
                  <Button
                    variant="outlined"
                    startIcon={refreshing ? <CircularProgress size={20} /> : <RefreshIcon />}
                    onClick={handleRefresh}
                    disabled={refreshing}
                  >
                    {refreshing ? '××¨×¢× ×Ÿ...' : '×¨×¢× ×Ÿ'}
                  </Button>
                </Box>

                <OnboardingDashboard
                  kidId={kidId}
                  onboardingData={currentProcess}
                  onFormSelect={handleFormSelect}
                  onSendToParent={handleSendToParent}
                />
              </>
            )}

            {viewMode === 'form' && selectedForm && (
              <Paper sx={{ borderRadius: 3, overflow: 'hidden', mb: 3 }}>
                <Box sx={{ p: 3, backgroundColor: 'grey.50', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <Box>
                    <Typography variant="h5" gutterBottom>
                      {selectedForm.form.formName}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      {selectedForm.form.formDescription}
                    </Typography>
                  </Box>
                  <Button
                    variant="outlined"
                    startIcon={<BackIcon />}
                    onClick={handleBackToDashboard}
                  >
                    ×—×–×¨×”
                  </Button>
                </Box>
                
                <Box sx={{ p: 3 }}>
                  <DynamicFormRenderer
                    form={selectedForm.form}
                    kidId={kidId}
                    onFormComplete={handleFormComplete}
                    showSendToParentOption={true}
                    readOnly={selectedForm.status === 'completed' || selectedForm.status === 'completed_by_parent'}
                  />
                </Box>
              </Paper>
            )}

            {viewMode === 'dashboard' && !currentProcess && !isNewKid && (
              <Alert severity="info" sx={{ mb: 3 }}>
                <AlertTitle>×œ× × ××¦× ×ª×”×œ×™×š ×§×œ×™×˜×”</AlertTitle>
                ×œ× × ××¦× ×ª×”×œ×™×š ×§×œ×™×˜×” ×¢×‘×•×¨ ×™×œ×“ ×–×”. ×™×™×ª×›×Ÿ ×©×”×ª×”×œ×™×š ×¢×“×™×™×Ÿ ×œ× ×”×ª×—×™×œ.
                <Box sx={{ mt: 2 }}>
                  <Button 
                    variant="contained" 
                    onClick={() => navigate(`/kids/onboarding/new`)}
                  >
                    ×”×ª×—×œ ×ª×”×œ×™×š ×§×œ×™×˜×” ×—×“×©
                  </Button>
                </Box>
              </Alert>
            )}
          </Box>
        </Fade>
      </Container>
    </LocalizationProvider>
  );
};

export default KidOnboarding;

#####################################################

// src/pages/kids/OnboardingDashboard.jsx
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import {
  Box, Paper, Typography, Grid, Card, CardContent, CardActions,
  Button, Chip, LinearProgress, IconButton, Tooltip, Divider,
  Alert, AlertTitle, Fade, Dialog, DialogTitle, DialogContent,
  DialogActions, CircularProgress
} from '@mui/material';
import {
  CheckCircle as CheckIcon,
  PlayArrow as StartIcon,
  Edit as EditIcon,
  Send as SendIcon,
  Schedule as ScheduleIcon,
  Email as EmailIcon,
  Warning as WarningIcon,
  Info as InfoIcon,
  Assignment as AssignmentIcon
} from '@mui/icons-material';
import { styled } from '@mui/material/styles';
import Swal from 'sweetalert2';
import VisibilityIcon from '@mui/icons-material/Visibility';
import { 
  completeFormStep, 
  sendFormToParent,
  updateFormStatusLocally 
} from '../../Redux/features/onboardingSlice';

// ×¢×™×¦×•×‘ ××•×ª×× ×œ×›×¨×˜×™×¡ ×˜×•×¤×¡
const FormCard = styled(Card)(({ theme, status }) => {
  const getCardStyles = () => {
    switch (status) {
      case 'completed':
      case 'completed_by_parent':
        return {
          borderLeft: `6px solid ${theme.palette.success.main}`,
          backgroundColor: theme.palette.success.light + '10',
        };
      case 'in_progress':
        return {
          borderLeft: `6px solid ${theme.palette.primary.main}`,
          backgroundColor: theme.palette.primary.light + '10',
        };
      case 'sent_to_parent':
        return {
          borderLeft: `6px solid ${theme.palette.info.main}`,
          backgroundColor: theme.palette.info.light + '10',
        };
      default:
        return {
          borderLeft: `6px solid ${theme.palette.grey[300]}`,
          backgroundColor: theme.palette.grey[50],
        };
    }
  };

  return {
    height: '100%',
    transition: 'all 0.3s ease',
    cursor: 'pointer',
    ...getCardStyles(),
    '&:hover': {
      transform: 'translateY(-4px)',
      boxShadow: theme.shadows[8],
    }
  };
});

const OnboardingDashboard = ({ 
  kidId, 
  onboardingData, 
  onFormSelect,
  onSendToParent,
  loading = false 
}) => {
  const dispatch = useDispatch();
  const [sendDialog, setSendDialog] = useState({ open: false, form: null });
  const { completingForm, sendingToParent } = useSelector(state => state.onboarding);

  if (!onboardingData) {
    return (
      <Alert severity="info" sx={{ mb: 3 }}>
        <AlertTitle>××™×Ÿ × ×ª×•× ×™ ×§×œ×™×˜×”</AlertTitle>
        ×œ× × ××¦× ×ª×”×œ×™×š ×§×œ×™×˜×” ×¢×‘×•×¨ ×™×œ×“ ×–×”
      </Alert>
    );
  }

  // ×¤×•× ×§×¦×™×•×ª ×¢×–×¨
  const getStatusConfig = (form) => {
    switch (form.status) {
      case 'completed':
        return {
          icon: <CheckIcon />,
          label: '×”×•×©×œ×',
          color: 'success',
          variant: 'filled'
        };
      case 'completed_by_parent':
        return {
          icon: <CheckIcon />,
          label: '×”×•×©×œ× ×¢"×™ ×”×•×¨×™×',
          color: 'success',
          variant: 'filled'
        };
      case 'in_progress':
        return {
          icon: <EditIcon />,
          label: '×‘×ª×”×œ×™×š',
          color: 'primary',
          variant: 'filled'
        };
      case 'sent_to_parent':
        return {
          icon: <EmailIcon />,
          label: '× ×©×œ×— ×œ×”×•×¨×™×',
          color: 'info',
          variant: 'filled'
        };
      default:
        return {
          icon: <ScheduleIcon />,
          label: '×œ× ×”×ª×—×™×œ',
          color: 'default',
          variant: 'outlined'
        };
    }
  };

  const getProgressPercentage = (form) => {
    if (form.totalQuestions === 0) return 0;
    return Math.round((form.answeredQuestions / form.totalQuestions) * 100);
  };

  const canEditForm = (form) => {
    return ['not_started', 'in_progress'].includes(form.status);
  };

  const canSendToParent = (form) => {
    return form.status === 'in_progress' && form.answeredQuestions > 0;
  };

  const isCompleted = (form) => {
    return ['completed', 'completed_by_parent'].includes(form.status);
  };

  // ×˜×™×¤×•×œ ×‘×¤×¢×•×œ×•×ª
  const handleFormClick = (form) => {
    // ×›×œ ×”×˜×¤×¡×™× × ×™×ª× ×™× ×œ×¢×¨×™×›×” - ×›×•×œ×œ ×”×˜×•×¤×¡ ×”×¨××©×•×Ÿ
    if (onFormSelect) {
      onFormSelect(form);
    }
  };

  const handleSendToParent = (form) => {
    setSendDialog({ open: true, form });
  };

  const confirmSendToParent = async () => {
    const { form } = sendDialog;
    setSendDialog({ open: false, form: null });

    try {
      await dispatch(sendFormToParent({ 
        kidId, 
        formId: form.form.formId 
      })).unwrap();

      Swal.fire({
        icon: 'success',
        title: '× ×©×œ×— ×‘×”×¦×œ×—×”!',
        text: `×”×˜×•×¤×¡ "${form.form.formName}" × ×©×œ×— ×œ×”×•×¨×™× ×œ××™×œ×•×™`,
        timer: 3000,
        showConfirmButton: false
      });

      if (onSendToParent) {
        onSendToParent(form);
      }
    } catch (error) {
      Swal.fire({
        icon: 'error',
        title: '×©×’×™××” ×‘×©×œ×™×—×”',
        text: error.message || '××™×¨×¢×” ×©×’×™××” ×‘×©×œ×™×—×ª ×”×˜×•×¤×¡ ×œ×”×•×¨×™×'
      });
    }
  };

  if (loading) {
    return (
      <Box sx={{ textAlign: 'center', py: 4 }}>
        <CircularProgress size={60} />
        <Typography variant="h6" sx={{ mt: 2 }}>
          ×˜×•×¢×Ÿ × ×ª×•× ×™ ×§×œ×™×˜×”...
        </Typography>
      </Box>
    );
  }

  return (
    <Box dir="rtl">
      {/* ×›×•×ª×¨×ª ×¢× ×¡×˜×˜×™×¡×˜×™×§×•×ª */}
      <Paper sx={{ p: 3, mb: 4, borderRadius: 3 }}>
        <Typography variant="h5" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <AssignmentIcon color="primary" />
          ×˜×¤×¡×™ ×§×œ×™×˜×”
        </Typography>
        
        <Grid container spacing={2} sx={{ mt: 1 }}>
          <Grid item xs={12} sm={3}>
            <Box sx={{ textAlign: 'center' }}>
              <Typography variant="h3" color="primary.main" fontWeight="bold">
                {onboardingData.completionPercentage}%
              </Typography>
              <Typography variant="body2" color="text.secondary">
                ×”×ª×§×“××•×ª ×›×œ×œ×™×ª
              </Typography>
            </Box>
          </Grid>
          <Grid item xs={12} sm={3}>
            <Box sx={{ textAlign: 'center' }}>
              <Typography variant="h3" color="success.main" fontWeight="bold">
                {onboardingData.completedForms}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                ×˜×¤×¡×™× ×”×•×©×œ××•
              </Typography>
            </Box>
          </Grid>
          <Grid item xs={12} sm={3}>
            <Box sx={{ textAlign: 'center' }}>
              <Typography variant="h3" color="warning.main" fontWeight="bold">
                {onboardingData.forms.filter(f => f.status === 'in_progress').length}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                ×‘×ª×”×œ×™×š
              </Typography>
            </Box>
          </Grid>
          <Grid item xs={12} sm={3}>
            <Box sx={{ textAlign: 'center' }}>
              <Typography variant="h3" color="info.main" fontWeight="bold">
                {onboardingData.forms.filter(f => f.status === 'sent_to_parent').length}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                × ×©×œ×—×• ×œ×”×•×¨×™×
              </Typography>
            </Box>
          </Grid>
        </Grid>

        <Box sx={{ mt: 3 }}>
          <LinearProgress 
            variant="determinate" 
            value={onboardingData.completionPercentage} 
            sx={{ height: 12, borderRadius: 6 }}
          />
        </Box>
      </Paper>

      {/* ×¨×©×ª ×›×¨×˜×™×¡×™ ×”×˜×¤×¡×™× */}
      <Grid container spacing={3}>
        {onboardingData.forms.map((form, index) => {
          const statusConfig = getStatusConfig(form);
          const progressPercentage = getProgressPercentage(form);

          return (
            <Grid item xs={12} md={6} lg={4} key={form.form.formId}>
              <Fade in={true} timeout={300 + (index * 100)}>
                <FormCard 
                  status={form.status}
                  onClick={() => handleFormClick(form)}
                >
                  <CardContent sx={{ pb: 1 }}>
                    {/* ×›×•×ª×¨×ª ×”×˜×•×¤×¡ */}
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
                      <Typography variant="h6" component="div" sx={{ fontWeight: 'bold', flex: 1 }}>
                        {form.form.formName}
                      </Typography>
                      <Chip
                        icon={statusConfig.icon}
                        label={statusConfig.label}
                        color={statusConfig.color}
                        variant={statusConfig.variant}
                        size="small"
                      />
                    </Box>

                    {/* ×ª×™××•×¨ ×”×˜×•×¤×¡ */}
                    <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                      {form.form.formDescription}
                    </Typography>

                    {/* ×”×ª×§×“××•×ª */}
                    {!form.form.isFirstStep && form.totalQuestions > 0 && (
                      <Box sx={{ mb: 2 }}>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                          <Typography variant="body2" color="text.secondary">
                            ×”×ª×§×“××•×ª:
                          </Typography>
                          <Typography variant="body2" fontWeight="bold">
                            {form.answeredQuestions}/{form.totalQuestions} ×©××œ×•×ª
                          </Typography>
                        </Box>
                        <LinearProgress 
                          variant="determinate" 
                          value={progressPercentage}
                          sx={{ height: 6, borderRadius: 3 }}
                        />
                      </Box>
                    )}

                    {/* ××™×“×¢ × ×•×¡×£ */}
                    {form.completedAt && (
                      <Typography variant="caption" color="success.main" sx={{ display: 'block', mt: 1 }}>
                        ×”×•×©×œ× ×‘: {new Date(form.completedAt).toLocaleDateString('he-IL')}
                      </Typography>
                    )}
                    
                    {form.sentToParentAt && (
                      <Typography variant="caption" color="info.main" sx={{ display: 'block', mt: 1 }}>
                        × ×©×œ×— ×œ×”×•×¨×™× ×‘: {new Date(form.sentToParentAt).toLocaleDateString('he-IL')}
                      </Typography>
                    )}
                  </CardContent>

                  {/* ×¤×¢×•×œ×•×ª */}
                  <CardActions sx={{ pt: 0, px: 2, pb: 2 }}>
                    <Box sx={{ display: 'flex', gap: 1, width: '100%' }}>
                      {/* ×›×œ ×”×˜×¤×¡×™× × ×™×ª× ×™× ×œ×¢×¨×™×›×” */}
                      {!isCompleted(form) && (
                        <Button
                          size="small"
                          variant="contained"
                          startIcon={form.status === 'not_started' ? <StartIcon /> : <EditIcon />}
                          onClick={(e) => {
                            e.stopPropagation();
                            handleFormClick(form);
                          }}
                          sx={{ flex: 1 }}
                        >
                          {form.status === 'not_started' ? '×”×ª×—×œ' : '×”××©×š'}
                        </Button>
                      )}

                      {/* ×©×œ×™×—×” ×œ×”×•×¨×™× - ×¨×§ ×œ×˜×¤×¡×™× ×©××™× × ×”×¨××©×•×Ÿ */}
                      {!form.form.isFirstStep && canSendToParent(form) && (
                        <Tooltip title="×©×œ×— ×˜×•×¤×¡ ×œ×”×•×¨×™× ×œ××™×œ×•×™">
                          <IconButton
                            size="small"
                            color="secondary"
                            onClick={(e) => {
                              e.stopPropagation();
                              handleSendToParent(form);
                            }}
                            disabled={sendingToParent}
                          >
                            <SendIcon />
                          </IconButton>
                        </Tooltip>
                      )}

                      {/* ×¦×¤×™×™×”/×¢×¨×™×›×” - ×ª××™×“ ×–××™×Ÿ */}
                      <Button
                        size="small"
                        variant={isCompleted(form) ? "outlined" : "contained"}
                        startIcon={isCompleted(form) ? <VisibilityIcon /> : <EditIcon />}
                        onClick={(e) => {
                          e.stopPropagation();
                          handleFormClick(form);
                        }}
                        sx={{ flex: 1 }}
                      >
                        {isCompleted(form) ? '×¦×¤×”/×¢×¨×•×š' : '×¢×¨×•×š'}
                      </Button>
                    </Box>
                  </CardActions>
                </FormCard>
              </Fade>
            </Grid>
          );
        })}
      </Grid>

      {/* ×“×™××œ×•×’ ××™×©×•×¨ ×©×œ×™×—×” ×œ×”×•×¨×™× */}
      <Dialog
        open={sendDialog.open}
        onClose={() => setSendDialog({ open: false, form: null })}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>×©×œ×™×—×ª ×˜×•×¤×¡ ×œ×”×•×¨×™×</DialogTitle>
        <DialogContent>
          <Typography>
            ×”×× ×‘×¨×¦×•× ×š ×œ×©×œ×•×— ××ª ×”×˜×•×¤×¡ "{sendDialog.form?.form?.formName}" ×œ×”×•×¨×™× ×œ××™×œ×•×™?
          </Typography>
          <Alert severity="info" sx={{ mt: 2 }}>
            ×”×˜×•×¤×¡ ×™×™×©×œ×— ×œ×”×•×¨×™× ×‘××™××™×™×œ/SMS ×¢× ×§×™×©×•×¨ ×œ××™×œ×•×™
          </Alert>
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={() => setSendDialog({ open: false, form: null })}
            disabled={sendingToParent}
          >
            ×‘×™×˜×•×œ
          </Button>
          <Button 
            onClick={confirmSendToParent}
            variant="contained"
            disabled={sendingToParent}
            startIcon={sendingToParent ? <CircularProgress size={20} /> : <SendIcon />}
          >
            {sendingToParent ? '×©×•×œ×—...' : '×©×œ×—'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default OnboardingDashboard;

###########################################################

// components/kids/ProgressLogo.jsx - ×’×¨×¡×” ××¢×•×“×›× ×ª ×¢× Dashboard
import { Box, Typography, Paper, Grid, Chip } from '@mui/material';
import { styled } from '@mui/material/styles';
import {
  CheckCircle as CheckIcon,
  Schedule as ScheduleIcon,
  Edit as EditIcon,
  Email as EmailIcon
} from '@mui/icons-material';

const IntegratedContainer = styled(Box)(({ theme }) => ({
  position: 'relative',
  width: '100%',
  marginBottom: theme.spacing(3),
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
}));

// ××–×•×¨ ×”×œ×•×’×• ×¢× ×”××¦×‘ ×”×©×œ× (×›×•×œ×œ ×”×œ×•×’×• ×”××ª××œ×)
const LogoArea = styled(Box)(({ theme }) => ({
  position: 'relative',
  width: '150px',
  height: '134px',
  marginBottom: '-10px', // ×©×œ×™×œ×™ ×›×“×™ ×œ×’×¨×•× ×œ×œ×•×’×• ×œ×—×¤×•×£ ×¢× ×”×˜×•×¤×¡
  zIndex: 2, // ××¢×œ ×”×˜×•×¤×¡
}));

// ××¢×˜×¤×ª ×”-SVG
const LogoWrapper = styled(Box)(({ theme }) => ({
  position: 'relative',
  width: '100%',
  height: '100%',
  overflow: 'visible',
}));

// SVG ×”××œ× (×¨×§×¢ ××¤×•×¨)
const LogoOutline = styled('svg')(({ theme }) => ({
  position: 'absolute',
  top: 0,
  left: 0,
  width: '100%',
  height: '100%',
  zIndex: 1,
}));

// SVG ×”××ª××œ× (×¦×‘×¢×•× ×™)
const LogoFill = styled('svg')(({ progress, theme }) => ({
  position: 'absolute',
  top: 0,
  left: 0,
  width: '100%',
  height: '100%',
  zIndex: 2,
  clipPath: `inset(${100 - progress}% 0 0 0)`, // ×—×™×ª×•×š ××œ××¢×œ×” ×›×œ×¤×™ ××˜×”
  transition: 'clip-path 0.8s ease-in-out',
}));

// ××—×•×– ×”×”×ª×§×“××•×ª
const ProgressText = styled(Typography)(({ theme }) => ({
  position: 'absolute',
  top: '50%',
  left: '50%',
  transform: 'translate(-50%, -50%)',
  fontWeight: 'bold',
  fontSize: '1.2rem',
  color: '#fff',
  zIndex: 3,
  backgroundColor: 'rgba(0,0,0,0.4)',
  padding: '4px 8px',
  borderRadius: '20px',
  textShadow: '0 1px 2px rgba(0,0,0,0.5)',
}));

// ×©× ×”×™×œ×“ (×× ×™×©)
const KidName = styled(Typography)(({ theme }) => ({
  position: 'absolute',
  bottom: '-5px',
  left: '50%',
  transform: 'translateX(-50%)',
  fontWeight: 'bold',
  fontSize: '0.95rem',
  backgroundColor: theme.palette.primary.main,
  color: '#fff',
  padding: '2px 12px',
  borderRadius: '12px',
  zIndex: 4,
  boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
  maxWidth: '90%',
  whiteSpace: 'nowrap',
  overflow: 'hidden',
  textOverflow: 'ellipsis',
}));

// ×¡×™×›×•× ×˜×¤×¡×™× ××ª×—×ª ×œ×œ×•×’×•
const FormsSummary = styled(Paper)(({ theme }) => ({
  padding: theme.spacing(2, 3, 3, 3),
  borderRadius: theme.spacing(2, 2, 2, 2),
  backgroundColor: theme.palette.grey[50],
  boxShadow: '0 -4px 20px rgba(0,0,0,0.05)',
  width: '100%',
  maxWidth: '800px',
  zIndex: 1
}));

const ProgressLogo = ({ 
  onboardingData = null,
  kidName = null, 
  showFormsSummary = true,
  compact = false
}) => {
  // ×—×™×©×•×‘ ×”××—×•×– ×©×”×•×©×œ×
  const progress = onboardingData?.completionPercentage || 0;
  
  const logoPath = "M338.307,72..."; // ×™×© ×œ×”×›× ×™×¡ ××ª ×”× ×ª×™×‘ ×”××œ× ×©×œ ×”×œ×•×’×• ×›××Ÿ
  // ×¤×•× ×§×¦×™×” ×œ×§×‘×œ×ª ×¡×˜×˜×•×¡ ××™×™×§×•×Ÿ
  const getStatusIcon = (status) => {
    switch (status) {
      case 'completed':
      case 'completed_by_parent':
        return <CheckIcon color="success" fontSize="small" />;
      case 'in_progress':
        return <EditIcon color="primary" fontSize="small" />;
      case 'sent_to_parent':
        return <EmailIcon color="info" fontSize="small" />;
      default:
        return <ScheduleIcon color="disabled" fontSize="small" />;
    }
  };

  // ×¤×•× ×§×¦×™×” ×œ×§×‘×œ×ª ×¦×‘×¢ ×¡×˜×˜×•×¡
  const getStatusColor = (status) => {
    switch (status) {
      case 'completed':
      case 'completed_by_parent':
        return 'success';
      case 'in_progress':
        return 'primary';
      case 'sent_to_parent':
        return 'info';
      default:
        return 'default';
    }
  };

  return (
    <IntegratedContainer>
      <LogoArea>
        <LogoWrapper>
          {/* ×”×œ×•×’×• ×”××¤×•×¨ (×¨×§×¢) */}
          <LogoOutline
            xmlns="http://www.w3.org/2000/svg" 
            viewBox="0 0 824.009 734.597"
          >
            <path 
              d={logoPath}
              transform="translate(1.003 1.007)" 
              fill="#f5f5f5"
              stroke="#e0e0e0"
              strokeWidth="2"
            />
          </LogoOutline>
          
          {/* ×”×œ×•×’×• ×”×¦×‘×¢×•× ×™ (××ª××œ×) */}
          <LogoFill
            xmlns="http://www.w3.org/2000/svg" 
            viewBox="0 0 824.009 734.597"
            progress={progress}
          >
            <defs>
              <linearGradient id="logoGradient" x1="100%" y1="100%" x2="100%" y2="0%">
                 <stop offset="0%" stopColor="#3F5AA7" />
                 <stop offset="25%" stopColor="#3E5BA1" />
                 <stop offset="50%" stopColor="#71C8DD" />
                 <stop offset="75%" stopColor="#8BCCC6" />
                 <stop offset="100%" stopColor="#73BFB5" />
               </linearGradient>
               <filter id="logoGlow" x="-20%" y="-20%" width="140%" height="140%">
                 <feGaussianBlur stdDeviation="5" result="blur" />
                 <feComposite in="SourceGraphic" in2="blur" operator="over" />
               </filter>
             </defs>
             <path 
               d={logoPath}
               transform="translate(1.003 1.007)" 
               fill="url(#logoGradient)"
               stroke="#4A8897"
               strokeWidth="2"
               filter="url(#logoGlow)"
            />
          </LogoFill>
          
          {/* ×”×¦×’×ª ××—×•×– ×”×”×ª×§×“××•×ª */}
          <ProgressText>{progress}%</ProgressText>
          
          {/* ×©× ×”×™×œ×“ ×× ×™×© */}
          {kidName && <KidName>{kidName}</KidName>}
        </LogoWrapper>
      </LogoArea>
      
      {/* ×¡×™×›×•× ×˜×¤×¡×™× */}
      {showFormsSummary && onboardingData && (
        <FormsSummary elevation={3}>
          {compact ? (
            // ×ª×¦×•×’×” ××¦×•××¦××ª
            <Box sx={{ textAlign: 'center' }}>
              <Typography variant="h6" gutterBottom>
                ×”×ª×§×“××•×ª ×§×œ×™×˜×”
              </Typography>
              <Typography variant="body2" color="text.secondary">
                {onboardingData.completedForms} ××ª×•×š {onboardingData.totalForms} ×˜×¤×¡×™× ×”×•×©×œ××•
              </Typography>
            </Box>
          ) : (
            // ×ª×¦×•×’×” ××œ××”
            <>
              <Typography variant="h6" gutterBottom sx={{ textAlign: 'center', mb: 3 }}>
                ×¡×˜×˜×•×¡ ×˜×¤×¡×™ ×”×§×œ×™×˜×”
              </Typography>
              
              <Grid container spacing={2}>
                {onboardingData.forms?.map((form, index) => (
                  <Grid item xs={12} sm={6} md={4} key={form.form.formId}>
                    <Box 
                      sx={{ 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: 1,
                        p: 1.5,
                        borderRadius: 2,
                        backgroundColor: 'white',
                        border: '1px solid',
                        borderColor: 'grey.200',
                        transition: 'all 0.2s ease',
                        '&:hover': {
                          borderColor: 'primary.main',
                          transform: 'translateY(-1px)'
                        }
                      }}
                    >
                      {getStatusIcon(form.status)}
                      <Box sx={{ flex: 1, minWidth: 0 }}>
                        <Typography 
                          variant="body2" 
                          fontWeight="medium"
                          sx={{ 
                            overflow: 'hidden',
                            textOverflow: 'ellipsis',
                            whiteSpace: 'nowrap'
                          }}
                        >
                          {form.form.formName}
                        </Typography>
                        {form.status === 'in_progress' && form.totalQuestions > 0 && (
                          <Typography variant="caption" color="text.secondary">
                            {form.answeredQuestions}/{form.totalQuestions} ×©××œ×•×ª
                          </Typography>
                        )}
                      </Box>
                      <Chip
                        size="small"
                        label={
                          form.status === 'completed' ? '×”×•×©×œ×' :
                          form.status === 'completed_by_parent' ? '×”×•×©×œ× ×¢"×™ ×”×•×¨×™×' :
                          form.status === 'in_progress' ? '×‘×ª×”×œ×™×š' :
                          form.status === 'sent_to_parent' ? '× ×©×œ×— ×œ×”×•×¨×™×' :
                          '×œ× ×”×ª×—×™×œ'
                        }
                        color={getStatusColor(form.status)}
                        variant={
                          ['completed', 'completed_by_parent', 'in_progress', 'sent_to_parent'].includes(form.status) 
                            ? 'filled' 
                            : 'outlined'
                        }
                      />
                    </Box>
                  </Grid>
                ))}
              </Grid>
            </>
          )}
        </FormsSummary>
      )}
    </IntegratedContainer>
  );
};

export default ProgressLogo;

##################################################

// src/pages/kids/DynamicFormRenderer.jsx - ×’×¨×¡×” ××©×•×¤×¨×ª
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import {
  Box, Paper, Typography, Alert, AlertTitle, CircularProgress,
  Button, Grid, Divider, Chip, Fade, LinearProgress, Snackbar
} from '@mui/material';
import {
  Save as SaveIcon,
  Send as SendIcon,
  CheckCircle as CheckIcon,
  Autorenew as AutoSaveIcon,    // ğŸ” Good for autosave
  Warning as WarningIcon
} from '@mui/icons-material';
import { useFormik } from 'formik';
import * as yup from 'yup';
import Swal from 'sweetalert2';

import { fetchQuestionsByFormId } from '../../Redux/features/questionsSlice';
import { 
  fetchFormAnswers, 
  saveFormAnswers, 
  updateLocalAnswer,
  setCurrentForm 
} from '../../Redux/features/answersSlice';
import QuestionRenderer from './QuestionRenderer';

const DynamicFormRenderer = ({ 
  form, 
  kidId, 
  onFormComplete, 
  showSendToParentOption = true,
  readOnly = false 
}) => {
  const dispatch = useDispatch();
  const [validationSchema, setValidationSchema] = useState(yup.object({}));
  const [progress, setProgress] = useState(0);
  const [autoSaveStatus, setAutoSaveStatus] = useState('idle'); // idle, saving, saved, error
  const [lastSaved, setLastSaved] = useState(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  
  const { 
    currentFormQuestions, 
    status: questionsStatus, 
    error: questionsError 
  } = useSelector(state => state.questions);
  
  const { 
    currentFormAnswers, 
    saveStatus, 
    error: answersError 
  } = useSelector(state => state.answers);

  // ×˜×¢×™× ×ª ×©××œ×•×ª ×•×ª×©×•×‘×•×ª ×‘×¢×ª ×˜×¢×™× ×ª ×”×§×•××¤×•× × ×˜×”
  useEffect(() => {
    if (form?.formId && kidId) {
      loadFormData();
    }
  }, [form?.formId, kidId]);

  // ×¢×“×›×•×Ÿ progress ×›××©×¨ ×”×ª×©×•×‘×•×ª ××©×ª× ×•×ª
  useEffect(() => {
    if (currentFormQuestions.length > 0) {
      calculateProgress();
    }
  }, [currentFormAnswers, currentFormQuestions]);

  // ×©××™×¨×” ××•×˜×•××˜×™×ª ×›×œ 30 ×©× ×™×•×ª ×× ×™×© ×©×™× ×•×™×™×
  useEffect(() => {
    if (!readOnly && hasUnsavedChanges) {
      const autoSaveInterval = setInterval(() => {
        handleAutoSave();
      }, 30000); // 30 ×©× ×™×•×ª

      return () => clearInterval(autoSaveInterval);
    }
  }, [hasUnsavedChanges, readOnly]);

  const loadFormData = async () => {
    try {
      // ×˜×¢×™× ×ª ×©××œ×•×ª ×”×˜×•×¤×¡
      await dispatch(fetchQuestionsByFormId(form.formId));
      
      // ×”×’×“×¨×ª ×”×˜×•×¤×¡ ×”× ×•×›×—×™
      dispatch(setCurrentForm({ kidId, formId: form.formId }));
      
      // ×˜×¢×™× ×ª ×ª×©×•×‘×•×ª ×§×™×™××•×ª
      await dispatch(fetchFormAnswers({ kidId, formId: form.formId }));
    } catch (error) {
      console.error('Error loading form data:', error);
    }
  };

  // ×™×¦×™×¨×ª ×¡×›×™××ª validation ×“×™× ××™×ª
  useEffect(() => {
    if (currentFormQuestions.length > 0) {
      const schema = {};
      
      currentFormQuestions.forEach(question => {
        let fieldSchema = yup.string();
        
        if (question.isMandatory) {
          fieldSchema = fieldSchema.required(`${question.questionText} ×”×•× ×©×“×” ×—×•×‘×”`);
        }
        
        // ×ª×§×™× ×•×ª × ×•×¡×¤×ª ×œ×¤×™ ×¡×•×’ ×”×©××œ×”
        if (question.questionType === 'email') {
          fieldSchema = fieldSchema.email('×›×ª×•×‘×ª ×“×•××´×œ ×œ× ×ª×§×™× ×”');
        } else if (question.questionType === 'number') {
          fieldSchema = yup.number().typeError('×™×© ×œ×”×–×™×Ÿ ××¡×¤×¨ ×ª×§×™×Ÿ');
          if (question.isMandatory) {
            fieldSchema = fieldSchema.required(`${question.questionText} ×”×•× ×©×“×” ×—×•×‘×”`);
          }
        } else if (question.questionType === 'date') {
          fieldSchema = yup.date().typeError('×ª××¨×™×š ×œ× ×ª×§×™×Ÿ');
          if (question.isMandatory) {
            fieldSchema = fieldSchema.required(`${question.questionText} ×”×•× ×©×“×” ×—×•×‘×”`);
          }
        }
        
        schema[`question_${question.questionNo}`] = fieldSchema;
        
        // ×ª××™×›×” ×‘×©×“×” "××—×¨"
        if (question.hasOther) {
          schema[`question_${question.questionNo}_other`] = yup.string();
        }
      });
      
      setValidationSchema(yup.object(schema));
    }
  }, [currentFormQuestions]);

  // ×—×™×©×•×‘ ××—×•×– ×”×”×ª×§×“××•×ª
  const calculateProgress = () => {
    if (currentFormQuestions.length === 0) return;
    
    const mandatoryQuestions = currentFormQuestions.filter(q => q.isMandatory);
    const answeredMandatory = mandatoryQuestions.filter(q => 
      currentFormAnswers.some(a => a.questionNo === q.questionNo && a.answer)
    );
    
    const totalAnswered = currentFormAnswers.filter(a => a.answer).length;
    const progressPercent = Math.round((totalAnswered / currentFormQuestions.length) * 100);
    const mandatoryProgress = mandatoryQuestions.length > 0 ? 
      Math.round((answeredMandatory.length / mandatoryQuestions.length) * 100) : 100;
    
    setProgress(progressPercent);
    
    // ×‘×“×™×§×” ×× ×›×œ ×”×©××œ×•×ª ×”×—×•×‘×” × ×¢× ×•
    return mandatoryProgress === 100;
  };

  // ×”×›× ×ª ×¢×¨×›×™× ×¨××©×•× ×™×™× ×œ×˜×•×¤×¡
  const getInitialValues = () => {
    const values = {};
    
    currentFormQuestions.forEach(question => {
      const existingAnswer = currentFormAnswers.find(a => a.questionNo === question.questionNo);
      values[`question_${question.questionNo}`] = existingAnswer?.answer || '';
      
      if (question.hasOther) {
        values[`question_${question.questionNo}_other`] = existingAnswer?.other || '';
      }
    });
    
    return values;
  };

  const formik = useFormik({
    initialValues: getInitialValues(),
    validationSchema: validationSchema,
    enableReinitialize: true,
    onSubmit: async (values) => {
      await handleFormSubmit(values, false);
    },
  });

  // ×¢×“×›×•×Ÿ ×¢×¨×›×™ ×”×˜×•×¤×¡ ×›××©×¨ ×”×ª×©×•×‘×•×ª ××©×ª× ×•×ª
  useEffect(() => {
    if (currentFormAnswers.length > 0) {
      const newValues = getInitialValues();
      formik.setValues(newValues);
    }
  }, [currentFormAnswers]);

  // ×©××™×¨×” ××•×˜×•××˜×™×ª
  const handleAutoSave = async () => {
    if (!hasUnsavedChanges || readOnly) return;
    
    setAutoSaveStatus('saving');
    try {
      const answers = prepareAnswersForSaving(formik.values);
      if (answers.length > 0) {
        await dispatch(saveFormAnswers({
          kidId,
          formId: form.formId,
          answers
        })).unwrap();
        
        setAutoSaveStatus('saved');
        setHasUnsavedChanges(false);
        setLastSaved(new Date());
        
        setTimeout(() => setAutoSaveStatus('idle'), 2000);
      }
    } catch (error) {
      setAutoSaveStatus('error');
      setTimeout(() => setAutoSaveStatus('idle'), 3000);
    }
  };

  // ×”×›× ×ª ×”×ª×©×•×‘×•×ª ×œ×©××™×¨×”
  const prepareAnswersForSaving = (values) => {
    const answers = [];
    
    currentFormQuestions.forEach(question => {
      const answer = values[`question_${question.questionNo}`];
      const other = values[`question_${question.questionNo}_other`];
      
      if (answer) {
        answers.push({
          questionNo: question.questionNo,
          answer: answer,
          other: other || null,
          byParent: false
        });
      }
    });
    
    return answers;
  };

  const handleFormSubmit = async (values, sendToParent = false) => {
    try {
      const answers = prepareAnswersForSaving(values);

      if (answers.length === 0) {
        Swal.fire({
          icon: 'warning',
          title: '×œ× × ××¦××• ×ª×©×•×‘×•×ª',
          text: '×™×© ×œ××œ× ×œ×¤×—×•×ª ×©××œ×” ××—×ª ×œ×¤× ×™ ×”×©××™×¨×”',
        });
        return;
      }

      // ×©××™×¨×ª ×”×ª×©×•×‘×•×ª
      await dispatch(saveFormAnswers({
        kidId,
        formId: form.formId,
        answers: answers.map(a => ({ ...a, byParent: sendToParent }))
      })).unwrap();

      setHasUnsavedChanges(false);

      if (sendToParent) {
        Swal.fire({
          icon: 'success',
          title: '× ×©×œ×— ×‘×”×¦×œ×—×”!',
          text: '×”×˜×•×¤×¡ × ×©×œ×— ×œ×”×•×¨×™× ×œ××™×œ×•×™',
          timer: 2000,
          showConfirmButton: false
        });
      } else {
        // ×‘×“×™×§×” ×× ×›×œ ×”×©××œ×•×ª ×”×—×•×‘×” × ×¢× ×•
        const allMandatoryAnswered = calculateProgress();
        
        if (allMandatoryAnswered) {
          const result = await Swal.fire({
            icon: 'success',
            title: '× ×©××¨ ×‘×”×¦×œ×—×”!',
            text: '×›×œ ×”×©××œ×•×ª ×”×—×•×‘×” × ×¢× ×•. ×”×× ×ª×¨×¦×” ×œ×¡××Ÿ ××ª ×”×˜×•×¤×¡ ×›××•×©×œ×?',
            showCancelButton: true,
            confirmButtonText: '×›×Ÿ, ×¡××Ÿ ×›××•×©×œ×',
            cancelButtonText: '×œ×, ×”××©×š ×¢×¨×™×›×”'
          });
          
          if (result.isConfirmed && onFormComplete) {
            onFormComplete(form.formId);
          }
        } else {
          Swal.fire({
            icon: 'info',
            title: '× ×©××¨ ×‘×”×¦×œ×—×”!',
            text: '×”×ª×©×•×‘×•×ª × ×©××¨×•. ×¢×“×™×™×Ÿ ×™×© ×©××œ×•×ª ×—×•×‘×” ×©×œ× × ×¢× ×•.',
            timer: 2000,
            showConfirmButton: false
          });
        }
      }
    } catch (error) {
      Swal.fire({
        icon: 'error',
        title: '×©×’×™××” ×‘×©××™×¨×”',
        text: error.message || '××™×¨×¢×” ×©×’×™××” ×‘×©××™×¨×ª ×”×˜×•×¤×¡',
      });
    }
  };

  const handleSendToParent = () => {
    Swal.fire({
      title: '×©×œ×™×—×ª ×˜×•×¤×¡ ×œ×”×•×¨×™×',
      text: '×”×× ×‘×¨×¦×•× ×š ×œ×©×œ×•×— ××ª ×”×˜×•×¤×¡ ×œ×”×•×¨×™× ×œ××™×œ×•×™?',
      icon: 'question',
      showCancelButton: true,
      confirmButtonText: '×›×Ÿ, ×©×œ×—',
      cancelButtonText: '×‘×™×˜×•×œ',
      confirmButtonColor: '#2196f3'
    }).then((result) => {
      if (result.isConfirmed) {
        handleFormSubmit(formik.values, true);
      }
    });
  };

  // ×¢×“×›×•×Ÿ ×ª×©×•×‘×” ××§×•××™×ª ×‘×–××Ÿ ×”×§×œ×“×”
  const handleQuestionChange = (questionNo, value, otherValue = null) => {
    // ×¢×“×›×•×Ÿ ×”Redux
    dispatch(updateLocalAnswer({
      questionNo,
      answer: value,
      other: otherValue
    }));
    
    // ×¢×“×›×•×Ÿ ×”Formik
    formik.setFieldValue(`question_${questionNo}`, value);
    if (otherValue !== null) {
      formik.setFieldValue(`question_${questionNo}_other`, otherValue);
    }
    
    // ×¡×™××•×Ÿ ×©×™×© ×©×™× ×•×™×™× ×œ× ×©××•×¨×™×
    setHasUnsavedChanges(true);
  };

  if (questionsStatus === 'loading') {
    return (
      <Box sx={{ textAlign: 'center', py: 4 }}>
        <CircularProgress size={60} />
        <Typography variant="h6" sx={{ mt: 2 }}>
          ×˜×•×¢×Ÿ ×©××œ×•×ª ×”×˜×•×¤×¡...
        </Typography>
      </Box>
    );
  }

  if (questionsError) {
    return (
      <Alert severity="error" sx={{ mb: 3 }}>
        <AlertTitle>×©×’×™××” ×‘×˜×¢×™× ×ª ×”×˜×•×¤×¡</AlertTitle>
        {questionsError}
      </Alert>
    );
  }

  if (currentFormQuestions.length === 0) {
    return (
      <Alert severity="warning" sx={{ mb: 3 }}>
        <AlertTitle>××™×Ÿ ×©××œ×•×ª</AlertTitle>
        ×œ× × ××¦××• ×©××œ×•×ª ×¢×‘×•×¨ ×˜×•×¤×¡ ×–×”
      </Alert>
    );
  }

  return (
    <Box dir="rtl">
      {/* ×¡×¨×’×œ ×”×ª×§×“××•×ª ××¢×•×“×›×Ÿ */}
      <Paper sx={{ p: 2, mb: 3, borderRadius: 2 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
          <Typography variant="body2" color="text.secondary" sx={{ minWidth: 120 }}>
            ×”×ª×§×“××•×ª ×”×˜×•×¤×¡:
          </Typography>
          <Box sx={{ flexGrow: 1, mx: 2 }}>
            <LinearProgress 
              variant="determinate" 
              value={progress} 
              sx={{ height: 8, borderRadius: 4 }}
            />
          </Box>
          <Typography variant="body2" color="primary" fontWeight="bold">
            {progress}%
          </Typography>
        </Box>
        
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <Typography variant="caption" color="text.secondary">
            {currentFormAnswers.length} ××ª×•×š {currentFormQuestions.length} ×©××œ×•×ª × ×¢× ×•
          </Typography>
          
          {/* ×¡×˜×˜×•×¡ ×©××™×¨×” ××•×˜×•××˜×™×ª */}
          {!readOnly && (
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
              {autoSaveStatus === 'saving' && (
                <>
                  <CircularProgress size={16} />
                  <Typography variant="caption" color="text.secondary">
                    ×©×•××¨...
                  </Typography>
                </>
              )}
              {autoSaveStatus === 'saved' && (
                <>
                  <CheckIcon fontSize="small" color="success" />
                  <Typography variant="caption" color="success.main">
                    × ×©××¨ ××•×˜×•××˜×™×ª
                  </Typography>
                </>
              )}
              {autoSaveStatus === 'error' && (
                <>
                  <WarningIcon fontSize="small" color="error" />
                  <Typography variant="caption" color="error.main">
                    ×©×’×™××” ×‘×©××™×¨×”
                  </Typography>
                </>
              )}
              {hasUnsavedChanges && autoSaveStatus === 'idle' && (
                <Typography variant="caption" color="warning.main">
                  ×™×© ×©×™× ×•×™×™× ×œ× ×©××•×¨×™×
                </Typography>
              )}
              {lastSaved && (
                <Typography variant="caption" color="text.secondary">
                  × ×©××¨ ×œ××—×¨×•× ×”: {lastSaved.toLocaleTimeString('he-IL')}
                </Typography>
              )}
            </Box>
          )}
        </Box>
      </Paper>

      {/* ×©×’×™××•×ª */}
      {answersError && (
        <Alert severity="error" sx={{ mb: 3 }}>
          <AlertTitle>×©×’×™××”</AlertTitle>
          {answersError}
        </Alert>
      )}

      <form onSubmit={formik.handleSubmit}>
        {/* ×¨× ×“×•×¨ ×©××œ×•×ª ×œ×¤×™ ×§×˜×’×•×¨×™×•×ª */}
        {Object.entries(groupQuestionsByCategory()).map(([category, questions], categoryIndex) => (
          <Fade in={true} timeout={300 + (categoryIndex * 200)} key={category}>
            <Paper 
              sx={{ 
                mb: 4, 
                borderRadius: 3,
                overflow: 'hidden',
                border: '1px solid',
                borderColor: 'grey.200'
              }}
            >
              {/* ×›×•×ª×¨×ª ×§×˜×’×•×¨×™×” */}
              <Box 
                sx={{ 
                  p: 2, 
                  backgroundColor: 'primary.main', 
                  color: 'white',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between'
                }}
              >
                <Typography variant="h6" fontWeight="bold">
                  {category}
                </Typography>
                <Chip 
                  label={`${questions.length} ×©××œ×•×ª`}
                  size="small"
                  sx={{ 
                    backgroundColor: 'rgba(255,255,255,0.2)', 
                    color: 'white',
                    fontWeight: 'bold'
                  }}
                />
              </Box>
              
              {/* ×©××œ×•×ª ×”×§×˜×’×•×¨×™×” */}
              <Box sx={{ p: 3 }}>
                <Grid container spacing={3}>
                  {questions
                    .sort((a, b) => a.questionNo - b.questionNo)
                    .map((question, index) => (
                      <Grid item xs={12} key={question.questionNo}>
                        <QuestionRenderer
                          question={question}
                          value={formik.values[`question_${question.questionNo}`] || ''}
                          otherValue={formik.values[`question_${question.questionNo}_other`] || ''}
                          error={formik.touched[`question_${question.questionNo}`] && 
                                 formik.errors[`question_${question.questionNo}`]}
                          onChange={(value, otherValue) => 
                            handleQuestionChange(question.questionNo, value, otherValue)
                          }
                          onBlur={() => formik.setFieldTouched(`question_${question.questionNo}`, true)}
                          readOnly={readOnly}
                        />
                      </Grid>
                    ))}
                </Grid>
              </Box>
            </Paper>
          </Fade>
        ))}

        {!readOnly && (
          <>
            <Divider sx={{ my: 4 }} />
            
            {/* ×›×¤×ª×•×¨×™ ×¤×¢×•×œ×” ××¢×•×“×›× ×™× */}
            <Box sx={{ 
              display: 'flex', 
              justifyContent: 'space-between',
              alignItems: 'center',
              flexWrap: 'wrap',
              gap: 2 
            }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                <Chip 
                  icon={<CheckIcon />}
                  label={`${currentFormAnswers.length} ×ª×©×•×‘×•×ª × ×©××¨×•`}
                  color="success"
                  variant="outlined"
                  size="small"
                />
                
                {hasUnsavedChanges && (
                  <Chip 
                    icon={<AutoSaveIcon />}
                    label="×™×© ×©×™× ×•×™×™× ×œ× ×©××•×¨×™×"
                    color="warning"
                    variant="outlined"
                    size="small"
                  />
                )}
              </Box>

              <Box sx={{ display: 'flex', gap: 2 }}>
                {/* ×›×¤×ª×•×¨ ×©××™×¨×” ××•×˜×•××˜×™×ª ×™×“× ×™×ª */}
                <Button
                  variant="outlined"
                  startIcon={<AutoSaveIcon />}
                  onClick={handleAutoSave}
                  disabled={!hasUnsavedChanges || autoSaveStatus === 'saving'}
                >
                  ×©××•×¨ ×¢×›×©×™×•
                </Button>
                
                {showSendToParentOption && (
                  <Button
                    variant="outlined"
                    color="secondary"
                    startIcon={<SendIcon />}
                    onClick={handleSendToParent}
                    disabled={saveStatus === 'loading'}
                  >
                    ×©×œ×— ×œ×”×•×¨×™×
                  </Button>
                )}
                
                <Button
                  type="submit"
                  variant="contained"
                  startIcon={saveStatus === 'loading' ? <CircularProgress size={20} /> : <SaveIcon />}
                  disabled={saveStatus === 'loading'}
                  sx={{ minWidth: 140 }}
                >
                  {saveStatus === 'loading' ? '×©×•××¨...' : '×©××•×¨ ×•×”××©×š'}
                </Button>
              </Box>
            </Box>
          </>
        )}
      </form>

      {/* ×”×•×“×¢×ª ×©××™×¨×” ××•×˜×•××˜×™×ª */}
      <Snackbar
        open={autoSaveStatus === 'saved'}
        autoHideDuration={2000}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
        message="× ×©××¨ ××•×˜×•××˜×™×ª"
      />
    </Box>
  );
  
  // ×¤×•× ×§×¦×™×” ×œ×§×™×‘×•×¥ ×©××œ×•×ª ×œ×¤×™ ×§×˜×’×•×¨×™×”
  function groupQuestionsByCategory() {
    const grouped = {};
    currentFormQuestions.forEach(question => {
      const category = question.category || '×›×œ×œ×™';
      if (!grouped[category]) {
        grouped[category] = [];
      }
      grouped[category].push(question);
    });
    return grouped;
  }
};

export default DynamicFormRenderer;

##################################################

// src/pages/kids/QuestionRenderer.jsx
import React, { useState } from 'react';
import {
  TextField, FormControl, FormLabel, RadioGroup, FormControlLabel,
  Radio, Checkbox, FormGroup, Select, MenuItem, InputLabel,
  FormHelperText, Typography, Box, Paper, Chip, Switch,
  InputAdornment, IconButton, Tooltip
} from '@mui/material';
import {
  Info as InfoIcon,
  CalendarToday as CalendarIcon,
  Email as EmailIcon,
  Phone as PhoneIcon,
  Numbers as NumberIcon
} from '@mui/icons-material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { styled } from '@mui/material/styles';

// ×¢×™×¦×•×‘ ××•×ª×× ×œ×©××œ×” - ×¤×©×•×˜ ×™×•×ª×¨
const QuestionContainer = styled(Box)(({ theme, required }) => ({
  marginBottom: theme.spacing(3),
  padding: theme.spacing(2),
  borderRadius: theme.spacing(1),
  border: required ? `1px solid ${theme.palette.warning.light}` : `1px solid ${theme.palette.grey[300]}`,
  backgroundColor: theme.palette.background.paper,
  transition: 'all 0.2s ease',
  '&:focus-within': {
    borderColor: theme.palette.primary.main,
    boxShadow: `0 0 0 1px ${theme.palette.primary.main}25`,
  }
}));

const QuestionText = styled(Typography)(({ theme, required }) => ({
  fontWeight: 500,
  color: theme.palette.text.primary,
  marginBottom: theme.spacing(1.5),
  fontSize: '1rem',
  display: 'flex',
  alignItems: 'center',
  gap: theme.spacing(1)
}));

const RequiredIndicator = () => (
  <Typography component="span" sx={{ color: 'error.main', fontWeight: 'bold' }}>
    *
  </Typography>
);

const QuestionRenderer = ({
  question,
  value,
  otherValue,
  error,
  onChange,
  onBlur,
  readOnly = false
}) => {
  const [showOther, setShowOther] = useState(false);

  // ×¤×™×¦×•×œ ×”×¢×¨×›×™× ×”××¤×©×¨×™×™× (××•×¤×¨×“×™× ×‘×¤×¡×™×§×™×)
  const possibleValues = question.possibleValues ? 
    question.possibleValues.split(',').map(val => val.trim()) : [];

  // ×˜×™×¤×•×œ ×‘×©×™× ×•×™ ×¢×¨×š
  const handleValueChange = (newValue, newOtherValue = null) => {
    onChange(newValue, newOtherValue);
    
    // ×”×¦×’×ª ×©×“×” "××—×¨" ×× × ×‘×—×¨×” ×”××¤×©×¨×•×ª "××—×¨"
    if (question.hasOther && (newValue === '××—×¨' || newValue?.includes?.('××—×¨'))) {
      setShowOther(true);
    } else {
      setShowOther(false);
    }
  };

  // ×¨× ×“×•×¨ ×œ×¤×™ ×¡×•×’ ×”×©××œ×”
  const renderQuestionInput = () => {
    switch (question.questionType) {
      case 'text':
      case 'textArea':
        return (
          <TextField
            fullWidth
            multiline={question.questionType === 'textArea'}
            rows={question.questionType === 'textArea' ? 4 : 1}
            value={value}
            onChange={(e) => handleValueChange(e.target.value)}
            onBlur={onBlur}
            error={!!error}
            helperText={error}
            placeholder={`×”×–×Ÿ ${question.questionText}`}
            disabled={readOnly}
            InputProps={{
              startAdornment: question.questionType === 'textArea' ? null : (
                <InputAdornment position="start">
                  <InfoIcon color="action" fontSize="small" />
                </InputAdornment>
              )
            }}
          />
        );

      case 'email':
        return (
          <TextField
            fullWidth
            type="email"
            value={value}
            onChange={(e) => handleValueChange(e.target.value)}
            onBlur={onBlur}
            error={!!error}
            helperText={error}
            placeholder="example@mail.com"
            disabled={readOnly}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <EmailIcon color="primary" fontSize="small" />
                </InputAdornment>
              )
            }}
          />
        );

      case 'phone':
        return (
          <TextField
            fullWidth
            type="tel"
            value={value}
            onChange={(e) => handleValueChange(e.target.value)}
            onBlur={onBlur}
            error={!!error}
            helperText={error}
            placeholder="05X-XXXXXXX"
            disabled={readOnly}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <PhoneIcon color="primary" fontSize="small" />
                </InputAdornment>
              )
            }}
          />
        );

      case 'number':
        return (
          <TextField
            fullWidth
            type="number"
            value={value}
            onChange={(e) => handleValueChange(e.target.value)}
            onBlur={onBlur}
            error={!!error}
            helperText={error}
            placeholder="×”×–×Ÿ ××¡×¤×¨"
            disabled={readOnly}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <NumberIcon color="primary" fontSize="small" />
                </InputAdornment>
              )
            }}
          />
        );

      case 'date':
        return (
          <DatePicker
            value={value ? new Date(value) : null}
            onChange={(newDate) => handleValueChange(newDate?.toISOString())}
            disabled={readOnly}
            slots={{
              textField: TextField
            }}
            slotProps={{
              textField: {
                fullWidth: true,
                error: !!error,
                helperText: error,
                InputProps: {
                  startAdornment: (
                    <InputAdornment position="start">
                      <CalendarIcon color="primary" fontSize="small" />
                    </InputAdornment>
                  )
                }
              }
            }}
          />
        );

      case 'boolean':
      case 'yesNo':
        return (
          <FormControl component="fieldset" error={!!error}>
            <RadioGroup
              row
              value={value}
              onChange={(e) => handleValueChange(e.target.value)}
            >
              <FormControlLabel
                value="×›×Ÿ"
                control={<Radio disabled={readOnly} />}
                label="×›×Ÿ"
              />
              <FormControlLabel
                value="×œ×"
                control={<Radio disabled={readOnly} />}
                label="×œ×"
              />
            </RadioGroup>
            {error && <FormHelperText>{error}</FormHelperText>}
          </FormControl>
        );

      case 'radio':
      case 'singleChoice':
        return (
          <FormControl component="fieldset" error={!!error} fullWidth>
            <RadioGroup
              value={value}
              onChange={(e) => handleValueChange(e.target.value)}
            >
              {possibleValues.map((option, index) => (
                <FormControlLabel
                  key={index}
                  value={option}
                  control={<Radio disabled={readOnly} />}
                  label={option}
                />
              ))}
              {question.hasOther && (
                <FormControlLabel
                  value="××—×¨"
                  control={<Radio disabled={readOnly} />}
                  label="××—×¨"
                />
              )}
            </RadioGroup>
            {error && <FormHelperText>{error}</FormHelperText>}
          </FormControl>
        );

      case 'checkbox':
      case 'multiChoice':
        const selectedValues = value ? value.split(',').map(v => v.trim()) : [];
        
        const handleCheckboxChange = (optionValue, checked) => {
          let newValues = [...selectedValues];
          
          if (checked) {
            if (!newValues.includes(optionValue)) {
              newValues.push(optionValue);
            }
          } else {
            newValues = newValues.filter(v => v !== optionValue);
          }
          
          // ×‘×“×™×§×ª ××’×‘×œ×ª ×›××•×ª ×”×¢×¨×›×™×
          if (question.howManyValues && newValues.length > question.howManyValues) {
            newValues = newValues.slice(0, question.howManyValues);
          }
          
          handleValueChange(newValues.join(', '));
        };

        return (
          <FormControl component="fieldset" error={!!error} fullWidth>
            <FormGroup>
              {possibleValues.map((option, index) => (
                <FormControlLabel
                  key={index}
                  control={
                    <Checkbox
                      checked={selectedValues.includes(option)}
                      onChange={(e) => handleCheckboxChange(option, e.target.checked)}
                      disabled={readOnly}
                    />
                  }
                  label={option}
                />
              ))}
              {question.hasOther && (
                <FormControlLabel
                  control={
                    <Checkbox
                      checked={selectedValues.includes('××—×¨')}
                      onChange={(e) => handleCheckboxChange('××—×¨', e.target.checked)}
                      disabled={readOnly}
                    />
                  }
                  label="××—×¨"
                />
              )}
            </FormGroup>
            {question.howManyValues && (
              <FormHelperText>
                × ×™×ª×Ÿ ×œ×‘×—×•×¨ ×¢×“ {question.howManyValues} ××¤×©×¨×•×™×•×ª
              </FormHelperText>
            )}
            {error && <FormHelperText>{error}</FormHelperText>}
          </FormControl>
        );

      case 'select':
      case 'dropdown':
        return (
          <FormControl fullWidth error={!!error}>
            <InputLabel>×‘×—×¨ ××¤×©×¨×•×ª</InputLabel>
            <Select
              value={value}
              onChange={(e) => handleValueChange(e.target.value)}
              onBlur={onBlur}
              label="×‘×—×¨ ××¤×©×¨×•×ª"
              disabled={readOnly}
            >
              <MenuItem value="">
                <em>×‘×—×¨ ××¤×©×¨×•×ª</em>
              </MenuItem>
              {possibleValues.map((option, index) => (
                <MenuItem key={index} value={option}>
                  {option}
                </MenuItem>
              ))}
              {question.hasOther && (
                <MenuItem value="××—×¨">××—×¨</MenuItem>
              )}
            </Select>
            {error && <FormHelperText>{error}</FormHelperText>}
          </FormControl>
        );

      case 'switch':
        return (
          <FormControlLabel
            control={
              <Switch
                checked={value === 'true' || value === true}
                onChange={(e) => handleValueChange(e.target.checked.toString())}
                disabled={readOnly}
              />
            }
            label={value === 'true' || value === true ? '×›×Ÿ' : '×œ×'}
          />
        );

      default:
        return (
          <TextField
            fullWidth
            value={value}
            onChange={(e) => handleValueChange(e.target.value)}
            onBlur={onBlur}
            error={!!error}
            helperText={error}
            placeholder={`×”×–×Ÿ ${question.questionText}`}
            disabled={readOnly}
          />
        );
    }
  };

  return (
    <QuestionContainer required={question.isMandatory}>
      <QuestionText required={question.isMandatory}>
        {question.questionText}
        {question.isMandatory && <RequiredIndicator />}
      </QuestionText>

      {renderQuestionInput()}

      {/* ×©×“×” "××—×¨" */}
      {question.hasOther && (showOther || (value === '××—×¨' || value?.includes?.('××—×¨'))) && (
        <Box sx={{ mt: 2 }}>
          <TextField
            fullWidth
            label="×¤×¨×˜:"
            value={otherValue || ''}
            onChange={(e) => onChange(value, e.target.value)}
            disabled={readOnly}
            placeholder="×”×–×Ÿ ×¤×™×¨×•×˜ × ×•×¡×£..."
            size="small"
          />
        </Box>
      )}
    </QuestionContainer>
  );
};

export default QuestionRenderer;

###########################################

// src/pages/kids/PersonalInfoForm.jsx - ×¢×™×¦×•×‘ ××˜×•×¨×£ + ×ª×™×§×•× ×™× ×˜×›× ×™×™×
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import {
  Grid, Typography, TextField, MenuItem, FormControl,
  InputLabel, Select, Button, Box, Avatar, FormHelperText, 
  Alert, AlertTitle, InputAdornment, Tooltip, CircularProgress,
  Paper, Divider, Chip, RadioGroup, FormControlLabel, Radio,
  FormLabel, Fade, Zoom, Card, CardContent, Badge, 
  IconButton, Stack, Switch, Collapse, useTheme
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { styled } from '@mui/material/styles';
import {
  Edit as EditIcon,
  Save as SaveIcon,
  Cancel as CancelIcon,
  DeleteOutline as DeleteIcon,
  CloudUpload as UploadIcon,
  Info as InfoIcon,
  ContactPhone as CallIcon,
  Email as EmailIcon,
  Home as HomeIcon,
  Work as WorkIcon,
  Person as PersonIcon,
  PersonAdd as PersonAddIcon,
  Cake as CakeIcon,
  Wc as GenderIcon,
  MedicalServices as MedicalIcon,
  LocationCity as CityIcon,
  LocalHospital as HospitalIcon,
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  Event as EventIcon,
  Face as FaceIcon,
  NavigateNext as NextIcon,
  LocalPhone as PhoneIcon,
  School as SchoolIcon,
  AddToPhotos as FileIcon,
} from '@mui/icons-material';
import MaleIcon from '@mui/icons-material/Male';
import FemaleIcon from '@mui/icons-material/Female'
import BadgeIcon from '@mui/icons-material/Badge';
import Swal from 'sweetalert2';
import { useFormik } from 'formik';
import * as yup from 'yup';
import { fetchCities } from '../../Redux/features/citiesSlice';
import { fetchClasses } from '../../Redux/features/classesSlice';
import { fetchHealthInsurances } from '../../Redux/features/healthinsurancesSlice';
import { fetchParentById } from '../../Redux/features/parentSlice';
import { createKidWithParents, updateKidWithParents, fetchKids } from '../../Redux/features/kidsSlice';

// ×¢×™×¦×•×‘ ××©×•×¤×¨ ×œ××•×•×˜××¨ ×¢× ××¤×§×˜ ×”×‘×œ×˜×” ×•×–×•×”×¨
const EnhancedAvatar = styled(Avatar)(({ theme }) => ({
  width: 150,
  height: 150,
  border: `4px solid ${theme.palette.background.paper}`,
  boxShadow: `0 6px 20px rgba(0,0,0,0.2), 0 0 15px ${theme.palette.primary.light}`,
  transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
  '&:hover': {
    transform: 'scale(1.05)',
    boxShadow: `0 8px 25px rgba(0,0,0,0.3), 0 0 20px ${theme.palette.primary.main}`,
  }
}));

// ××™×›×œ ×ª××•× ×ª ×¤×¨×•×¤×™×œ ×¢× ××¤×§×˜ ××‘×¨×™×§
const ProfileImageContainer = styled(Box)(({ theme }) => ({
  position: 'relative',
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  marginBottom: theme.spacing(2),
  '&::after': {
    content: '""',
    position: 'absolute',
    top: '10%',
    left: '10%',
    right: '10%',
    height: '1px',
    background: 'linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent)',
    filter: 'blur(1px)',
    opacity: 0.7,
    animation: 'shimmer 2s infinite',
  },
  '@keyframes shimmer': {
    '0%': { transform: 'translateX(-100%)' },
    '100%': { transform: 'translateX(100%)' },
  }
}));

// ×›×¨×˜×™×¡×™×” ××•×’×“×œ×ª ×¢× ×”× ×¤×©×” ×œ×¤×ª×™×—×”
const AnimatedSection = styled(Card)(({ theme, expanded }) => ({
  marginBottom: theme.spacing(4),
  borderRadius: theme.spacing(2),
  boxShadow: expanded
    ? `0 8px 32px rgba(0,0,0,0.15), 0 0 0 2px ${theme.palette.primary.main}38`
    : '0 4px 12px rgba(0,0,0,0.05)',
  transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
  transform: expanded ? 'translateY(0)' : 'translateY(0)',
  overflow: 'hidden',
  '&:hover': {
    boxShadow: `0 8px 28px rgba(0,0,0,0.12), 0 0 0 2px ${theme.palette.primary.main}15`,
  },
}));

// ×›×•×ª×¨×ª ×¡×§×©×Ÿ ××§×¦×•×¢×™×ª
const SectionHeader = styled(Box)(({ theme }) => ({
  padding: theme.spacing(2, 3),
  background: 'linear-gradient(90deg, rgba(33,150,243,0.05) 0%, rgba(33,150,243,0.1) 100%)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'space-between',
  borderBottom: `1px solid ${theme.palette.divider}`,
  cursor: 'pointer',
  '&:hover': {
    background: 'linear-gradient(90deg, rgba(33,150,243,0.1) 0%, rgba(33,150,243,0.15) 100%)',
  },
}));

// ×›×•×ª×¨×ª ×›×¨×˜×™×¡×™×”
const SectionTitle = styled(Typography)(({ theme, expanded }) => ({
  display: 'flex',
  alignItems: 'center',
  fontWeight: 600,
  color: expanded ? theme.palette.primary.main : theme.palette.text.primary,
  transition: 'color 0.3s ease',
}));

// ××™×™×§×•×Ÿ ×¡×§×©×Ÿ ××•× ×¤×©
const SectionIcon = styled(Box)(({ theme, expanded }) => ({
  marginLeft: theme.spacing(2),
  marginRight: theme.spacing(2),
  color: expanded ? theme.palette.primary.main : theme.palette.primary.main,
  background: expanded ? 'rgba(33,150,243,0.1)' : 'transparent',
  borderRadius: '50%',
  padding: theme.spacing(1),
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  transition: 'all 0.3s ease',
}));

// ×›×¤×ª×•×¨ ××•× ×¤×©
const AnimatedButton = styled(Button)(({ theme }) => ({
  position: 'relative',
  overflow: 'hidden',
  transition: 'all 0.3s ease',
  '&::after': {
    content: '""',
    position: 'absolute',
    top: 0,
    left: '-100%',
    width: '100%',
    height: '100%',
    background: 'linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent)',
    transition: 'all 0.5s ease',
  },
  '&:hover::after': {
    left: '100%',
  },
}));

// ×›×¤×ª×•×¨ ×”×¢×œ××ª ×ª××•× ×” ××¢×•×¦×‘
const UploadButton = styled(Button)(({ theme }) => ({
  marginTop: theme.spacing(2),
  borderRadius: '20px',
  padding: theme.spacing(1, 3),
  boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
  background: 'linear-gradient(90deg, #2196f3, #64b5f6)',
  transition: 'all 0.3s ease',
  color: 'white',
  '&:hover': {
    background: 'linear-gradient(90deg, #1976d2, #2196f3)',
    boxShadow: '0 6px 15px rgba(0,0,0,0.2)',
  }
}));

// ×ª×™×‘×ª ×›×¤×ª×•×¨×™ ×¤×¢×•×œ×”
const ActionButtonsContainer = styled(Box)(({ theme }) => ({
  display: 'flex',
  justifyContent: 'space-between',
  marginTop: theme.spacing(4),
  padding: theme.spacing(2),
  borderTop: `1px solid ${theme.palette.divider}`,
  background: 'linear-gradient(to bottom, transparent, rgba(0,0,0,0.02))',
}));

// ×¡×›×™××ª ×•×œ×™×“×¦×™×” ××©×•×¤×¨×ª
const validationSchema = yup.object({
  // ×¤×¨×˜×™ ×”×™×œ×“
  firstName: yup.string().required('×©× ×¤×¨×˜×™ ×”×•× ×©×“×” ×—×•×‘×”'),
  lastName: yup.string().required('×©× ××©×¤×—×” ×”×•× ×©×“×” ×—×•×‘×”'),
  birthDate: yup.date().required('×ª××¨×™×š ×œ×™×“×” ×”×•× ×©×“×” ×—×•×‘×”')
    .max(new Date(), '×ª××¨×™×š ×œ×™×“×” ×œ× ×™×›×•×œ ×œ×”×™×•×ª ×‘×¢×ª×™×“')
    .test('age', '×”×’×™×œ ×—×™×™×‘ ×œ×”×™×•×ª ×‘×™×Ÿ 0-3 ×©× ×™×', 
      (value) => {
        if (!value) return true;
        const today = new Date();
        const threeYearsAgo = new Date();
        threeYearsAgo.setFullYear(today.getFullYear() - 3);
        return value >= threeYearsAgo;
      }),
  gender: yup.string().required('××™×Ÿ ×”×•× ×©×“×” ×—×•×‘×”'),
  cityName: yup.string().required('×¢×™×¨ ×”×™× ×©×“×” ×—×•×‘×”'),
  address: yup.string().required('×›×ª×•×‘×ª ×”×™× ×©×“×” ×—×•×‘×”'),
  hName: yup.string().required('×§×•×¤×ª ×—×•×œ×™× ×”×™× ×©×“×” ×—×•×‘×”'),
  idNumber: yup.string()
    .required('×ª×¢×•×“×ª ×–×”×•×ª ×”×™× ×©×“×” ×—×•×‘×”')
    .matches(/^\d{9}$/, '×ª×¢×•×“×ª ×–×”×•×ª ×¦×¨×™×›×” ×œ×”×›×™×œ 9 ×¡×¤×¨×•×ª'),
  
  // ×¤×¨×˜×™ ×”×•×¨×” ×¨××©×™
  parent1FirstName: yup.string().required('×©× ×”×•×¨×” ×¨××©×™ ×”×•× ×©×“×” ×—×•×‘×”'),
  parent1LastName: yup.string().required('×©× ××©×¤×—×” ×”×•×¨×” ×¨××©×™ ×”×•× ×©×“×” ×—×•×‘×”'),
  parent1Mobile: yup.string()
    .required('×˜×œ×¤×•×Ÿ × ×™×™×“ ×”×•×¨×” ×¨××©×™ ×”×•× ×©×“×” ×—×•×‘×”')
    .matches(/^05\d{8}$/, '××¡×¤×¨ ×˜×œ×¤×•×Ÿ ×œ× ×ª×§×™×Ÿ'),
  parent1Email: yup.string().email('×›×ª×•×‘×ª ×“×•××´×œ ×œ× ×ª×§×™× ×”').required('×“×•××´×œ ×”×•×¨×” ×¨××©×™ ×—×•×‘×”'),

  // ×¤×¨×˜×™ ×”×•×¨×” ××©× ×™ (×œ× ×—×•×‘×”)
  parent2Mobile: yup.string()
    .nullable()
    .test('valid-phone', '××¡×¤×¨ ×˜×œ×¤×•×Ÿ ×œ× ×ª×§×™×Ÿ', (value) => {
      return !value || /^05\d{8}$/.test(value);
    }),
  parent2Email: yup.string().nullable().email('×›×ª×•×‘×ª ×“×•××´×œ ×œ× ×ª×§×™× ×”'),
});

const PersonalInfoForm = ({ data, onUpdate, isEditMode = false }) => {
  const dispatch = useDispatch();
  const theme = useTheme();
  const [photoFile, setPhotoFile] = useState(null);
  const [photoPreview, setPhotoPreview] = useState(data?.photoPath || null);
  
  // ××¦×‘×™ ×”×ª×¨×—×‘×•×ª ×”×¡×§×©× ×™×
  const [expandedSections, setExpandedSections] = useState({
    childDetails: true,
    primaryParent: false,
    secondaryParent: false, 
  });
  
  const toggleSection = (section) => {
    setExpandedSections(prev => ({
      ...prev,
      [section]: !prev[section]
    }));
  };
  
  // ×©×œ×™×¤×ª × ×ª×•× ×™ ×¨×¤×¨× ×¡ ××”×¡×˜×•×¨
  const { cities, status: citiesStatus } = useSelector(state => state.cities);
  const { kids, status: kidStatus, error: kidError } = useSelector(state => state.kids);
  const { classes, status: classesStatus } = useSelector(state => state.classes || { classes: [], status: 'idle' });
  const { healthInsurances, status: healthInsurancesStatus } = useSelector(state => state.healthInsurances);
  const isLoading = kidStatus === 'loading';
  
  // ×”×’×“×¨×ª initialValues ××ª×§× ×ª ×œ×”×•×¨×™×
  const getInitialValues = () => {
    if (data && isEditMode) {
      return {
        // ×¤×¨×˜×™ ×”×™×œ×“
        id: data.id || 0,
        idNumber: data.id || 0,
        firstName: data.firstName || '',
        lastName: data.lastName || '',
        birthDate: data.birthDate ? new Date(data.birthDate) : null,
        gender: data.gender || '',
        cityName: data.cityName || '',
        address: data.address || '',
        hName: data.hName || '',
        photo: data.photo || '',
        classId: data.classId || '',
        pathToFolder: data.pathToFolder || '',
        isActive: data.isActive !== undefined ? data.isActive : true,
        
        // ×¤×¨×˜×™ ×”×•×¨×” ×¨××©×™ - ×¢×›×©×™×• ×¢× ×”× ×ª×•× ×™× ×”× ×›×•× ×™×
        parent1Id: data.parentId1 || 0,
        parent1FirstName: data.parent1FirstName || '',
        parent1LastName: data.parent1LastName || '',
        parent1Mobile: data.parent1Mobile || '',
        parent1Email: data.parent1Email || '',
        parent1Address: data.parent1Address || data.address || '',
        parent1CityName: data.parent1CityName || data.cityName || '',
        
        // ×¤×¨×˜×™ ×”×•×¨×” ××©× ×™
        parent2Id: data.parentId2 || 0,
        parent2FirstName: data.parent2FirstName || '',
        parent2LastName: data.parent2LastName || '',
        parent2Mobile: data.parent2Mobile || '',
        parent2Email: data.parent2Email || '',
        parent2Address: data.parent2Address || '',
        parent2CityName: data.parent2CityName || '',
        
        // ×¤×¨×˜×™ ×§×©×¨ × ×•×¡×¤×™×
        homePhone: data.homePhone || '',
      };
    }
    
    // ×¢×¨×›×™× ×¨×™×§×™× ×¢×‘×•×¨ ×™×œ×“ ×—×“×©
    return {
      id: 0,
      idNumber: '',
      firstName: '',
      lastName: '',
      birthDate: null,
      gender: '',
      cityName: '',
      address: '',
      hName: '',
      photo: '',
      classId: '',
      pathToFolder: '',
      isActive: true,
      parent1Id: 0,
      parent1FirstName: '',
      parent1LastName: '',
      parent1Mobile: '',
      parent1Email: '',
      parent1Address: '',
      parent1CityName: '',
      parent2Id: 0,
      parent2FirstName: '',
      parent2LastName: '',
      parent2Mobile: '',
      parent2Email: '',
      parent2Address: '',
      parent2CityName: '',
      homePhone: '',
    };
  };

  // ×˜×¢×™× ×ª × ×ª×•× ×™ ×¨×¤×¨× ×¡ + × ×ª×•× ×™ ×”×•×¨×™× ×‘××¦×‘ ×¢×¨×™×›×”
  useEffect(() => {
    dispatch(fetchCities());
    dispatch(fetchClasses());
    dispatch(fetchHealthInsurances());
    dispatch(fetchKids());
    
    // ×˜×¢×™× ×ª × ×ª×•× ×™ ×”×•×¨×™× ×‘××¦×‘ ×¢×¨×™×›×”
    if (isEditMode && data) {
      loadParentsData();
    }
  }, [dispatch, data, isEditMode]);

  // ×˜×¢×™× ×ª × ×ª×•× ×™ ×”×•×¨×™×
  const loadParentsData = async () => {
    try {
      if (data.parentId1) {
        const parent1Result = await dispatch(fetchParentById(data.parentId1)).unwrap();
        // ×¢×“×›×•×Ÿ ×”×˜×•×¤×¡ ×¢× × ×ª×•× ×™ ×”×•×¨×” ×¨××©×™
        formik.setValues(prev => ({
          ...prev,
          parent1FirstName: parent1Result.firstName || '',
          parent1LastName: parent1Result.lastName || '',
          parent1Mobile: parent1Result.mobilePhone || '',
          parent1Email: parent1Result.email || '',
          parent1Address: parent1Result.address || '',
          parent1CityName: parent1Result.cityName || '',
        }));
      }
      
      if (data.parentId2) {
        const parent2Result = await dispatch(fetchParentById(data.parentId2)).unwrap();
        // ×¢×“×›×•×Ÿ ×”×˜×•×¤×¡ ×¢× × ×ª×•× ×™ ×”×•×¨×” ××©× ×™
        formik.setValues(prev => ({
          ...prev,
          parent2FirstName: parent2Result.firstName || '',
          parent2LastName: parent2Result.lastName || '',
          parent2Mobile: parent2Result.mobilePhone || '',
          parent2Email: parent2Result.email || '',
          parent2Address: parent2Result.address || '',
          parent2CityName: parent2Result.cityName || '',
        }));
      }
    } catch (error) {
      console.error('Error loading parents data:', error);
    }
  };

  useEffect(() => {
    if (data && isEditMode) {
      formik.resetForm({ values: getInitialValues() });
    }
  }, [data, isEditMode]);

  // ×˜×™×¤×•×œ ×‘×”×¢×œ××ª ×ª××•× ×”
  const handlePhotoChange = (event) => {
    if (event.target.files && event.target.files[0]) {
      const file = event.target.files[0];
      setPhotoFile(file);
      
      const reader = new FileReader();
      reader.onload = (e) => {
        setPhotoPreview(e.target.result);
      };
      reader.readAsDataURL(file);
    }
  };
  
  // ××™××•×© ×”-Formik
  const formik = useFormik({
    initialValues: getInitialValues(),
    validationSchema: validationSchema,
    enableReinitialize: true,
    onSubmit: async (values) => {
      try {
        // ×‘×“×™×§×” ×× ×™×œ×“ ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª (×¨×§ ×‘××¦×‘ ×™×¦×™×¨×” ×—×“×©×”)
        if (!isEditMode) {
          const existingKid = kids.find(kid => kid.id === Number(values.idNumber));
          if (existingKid) {
            Swal.fire({
              icon: 'warning',
              title: '×”×™×œ×“ ×§×™×™× ×‘××¢×¨×›×ª',
              text: '×‘××™×“×” ×•×‘×¨×¦×•× ×š ×œ×¢×“×›×Ÿ ××ª ×¤×¨×˜×™ ×”×™×œ×“, ×ª×™×’×© ×œ×¨×©×™××ª ×™×œ×“×™×',
              confirmButtonText: '××•×§×™'
            });
            return;
          }
        }

        // ×”×›× ×ª ×”× ×ª×•× ×™× ×œ×©××™×¨×” ×‘×¤×•×¨××˜ ×©×”-slice ××¦×¤×” ×œ×•
        const formDataForSlice = {
          // × ×ª×•× ×™ ×™×œ×“
          id: values.id,
          idNumber: values.idNumber || values.id,
          firstName: values.firstName,
          lastName: values.lastName,
          birthDate: values.birthDate,
          gender: values.gender,
          cityName: values.cityName,
          address: values.address,
          hName: values.hName,
          photo: values.photo,
          classId: values.classId || null,
          pathToFolder: values.pathToFolder,
          isActive: values.isActive,
          
          // × ×ª×•× ×™ ×”×•×¨×” ×¨××©×™
          parent1Id: values.parent1Id,
          parent1FirstName: values.parent1FirstName,
          parent1LastName: values.parent1LastName,
          parent1Mobile: values.parent1Mobile,
          parent1Email: values.parent1Email,
          parent1Address: values.parent1Address,
          parent1CityName: values.parent1CityName,
          
          // × ×ª×•× ×™ ×”×•×¨×” ××©× ×™
          parent2Id: values.parent2Id,
          parent2FirstName: values.parent2FirstName,
          parent2LastName: values.parent2LastName,
          parent2Mobile: values.parent2Mobile,
          parent2Email: values.parent2Email,
          parent2Address: values.parent2Address,
          parent2CityName: values.parent2CityName,
          
          // × ×ª×•× ×™ ×§×©×¨ × ×•×¡×¤×™×
          homePhone: values.homePhone,
        };

        let result;
        
        if (isEditMode) {
          result = await dispatch(updateKidWithParents(formDataForSlice)).unwrap();
          
          Swal.fire({
            icon: 'success',
            title: '×¢×•×“×›×Ÿ ×‘×”×¦×œ×—×”!',
            text: `×¤×¨×˜×™ ×”×™×œ×“ ${result.kid.firstName} ${result.kid.lastName} ×¢×•×“×›× ×• ×‘×”×¦×œ×—×”`,
            timer: 2000,
            showConfirmButton: false
          });
        } else {
          result = await dispatch(createKidWithParents(formDataForSlice)).unwrap();
          
          Swal.fire({
            icon: 'success',
            title: '× ×©××¨ ×‘×”×¦×œ×—×”!',
            text: `×¤×¨×˜×™ ×”×™×œ×“ ${result.kid.firstName} ${result.kid.lastName} × ×©××¨×• ×‘×”×¦×œ×—×”`,
            timer: 2000,
            showConfirmButton: false
          });
        }
        
        // ×¢×“×›×•×Ÿ ×”-parent component
        onUpdate(result.kid);
        
      } catch (error) {
        console.error('×©×’×™××” ×‘×©××™×¨×ª × ×ª×•× ×™ ×”×™×œ×“ ×•×”×”×•×¨×™×:', error);
        Swal.fire({
          icon: 'error',
          title: '×©×’×™××” ×‘×©××™×¨×ª ×”× ×ª×•× ×™×',
          text: error.message || '××™×¨×¢×” ×©×’×™××” ×‘×œ×ª×™ ×¦×¤×•×™×”, ×× × × ×¡×” ×©× ×™×ª',
        });
      }
    },
  });
  
  const isFormFilled = formik.dirty && Object.values(formik.values).some(val => val !== '');

  return (
    <form dir="rtl" onSubmit={formik.handleSubmit}>
      {/* ×”×•×“×¢×ª ×©×’×™××” ×× ×™×© */}
      {kidError && (
        <Zoom in={true}>
          <Alert
            severity="error"
            sx={{
              mb: 3,
              borderRadius: 2,
              boxShadow: "0 4px 15px rgba(211, 47, 47, 0.2)",
            }}
            variant="filled"
            icon={<ErrorIcon />}
          >
            <AlertTitle>×©×’×™××”</AlertTitle>
            {kidError}
          </Alert>
        </Zoom>
      )}

      {/* ×ª××•× ×ª ×¤×¨×•×¤×™×œ */}
      <ProfileImageContainer>
        <Badge
          overlap="circular"
          anchorOrigin={{ vertical: "top", horizontal: "right" }}
          badgeContent={
            <Tooltip title="×”×¢×œ××ª ×ª××•× ×”">
              <label htmlFor="kid-photo-upload">
                <IconButton
                  aria-label="×”×¢×œ××ª ×ª××•× ×”"
                  component="span"
                  sx={{
                    bgcolor: "primary.main",
                    color: "white",
                    "&:hover": { bgcolor: "primary.dark" },
                  }}
                  size="small"
                >
                  <UploadIcon fontSize="small" />
                </IconButton>
              </label>
            </Tooltip>
          }
        >
          <EnhancedAvatar src={photoPreview}>
            {!photoPreview && <FaceIcon sx={{ fontSize: 80, opacity: 0.7 }} />}
          </EnhancedAvatar>
        </Badge>

        <input
          accept="image/*"
          style={{ display: "none" }}
          id="kid-photo-upload"
          type="file"
          onChange={handlePhotoChange}
        />

        <Fade in={true} timeout={800}>
          <UploadButton
            variant="contained"
            component="label"
            htmlFor="kid-photo-upload"
            startIcon={<UploadIcon />}
            size="small"
          >
            {photoPreview ? "×”×—×œ×£ ×ª××•× ×”" : "×”×¢×œ××ª ×ª××•× ×”"}
          </UploadButton>
        </Fade>
      </ProfileImageContainer>

      {/* ×§×˜×¢ 1: ×¤×¨×˜×™ ×”×™×œ×“ */}
      <AnimatedSection expanded={expandedSections.childDetails}>
        <SectionHeader onClick={() => toggleSection("childDetails")}>
          <SectionIcon expanded={expandedSections.childDetails}>
            <PersonIcon />
          </SectionIcon>
          <SectionTitle variant="h6" expanded={expandedSections.childDetails}>
            ×¤×¨×˜×™ ×”×™×œ×“
            <Chip
              label="×¤×¨×˜×™× ×‘×¡×™×¡×™×™×"
              size="small"
              color={expandedSections.childDetails ? "primary" : "default"}
              sx={{ ml: 1, fontSize: "0.75rem" }}
            />
          </SectionTitle>
          <Box sx={{ ml: "auto" }}>
            <IconButton
              size="small"
              color={expandedSections.childDetails ? "primary" : "default"}
              sx={{
                transform: expandedSections.childDetails
                  ? "rotate(-90deg)"
                  : "rotate(0deg)",
                transition: "transform 0.3s ease",
              }}
            >
              <NextIcon />
            </IconButton>
          </Box>
        </SectionHeader>

        <Collapse in={expandedSections.childDetails}>
          <CardContent>
            <Grid container spacing={3}>
              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="firstName"
                  name="firstName"
                  label="×©× ×¤×¨×˜×™"
                  placeholder="×©× ×¤×¨×˜×™ ×©×œ ×”×™×œ×“"
                  value={formik.values.firstName}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={
                    formik.touched.firstName && Boolean(formik.errors.firstName)
                  }
                  helperText={
                    formik.touched.firstName && formik.errors.firstName
                  }
                  required
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <PersonIcon color="primary" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="lastName"
                  name="lastName"
                  label="×©× ××©×¤×—×”"
                  placeholder="×©× ××©×¤×—×” ×©×œ ×”×™×œ×“"
                  value={formik.values.lastName}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={
                    formik.touched.lastName && Boolean(formik.errors.lastName)
                  }
                  helperText={formik.touched.lastName && formik.errors.lastName}
                  required
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <PersonIcon color="primary" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="idNumber"
                  name="idNumber"
                  label="×ª×¢×•×“×ª ×–×”×•×ª"
                  placeholder="××¡×¤×¨ ×ª×¢×•×“×ª ×–×”×•×ª ×©×œ ×”×™×œ×“"
                  value={formik.values.idNumber}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={formik.touched.idNumber && Boolean(formik.errors.idNumber)}
                  helperText={formik.touched.idNumber && formik.errors.idNumber}
                  required
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <BadgeIcon color="primary" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <DatePicker
                  label="×ª××¨×™×š ×œ×™×“×”"
                  value={formik.values.birthDate}
                  onChange={(date) => formik.setFieldValue("birthDate", date)}
                  slots={{
                    textField: TextField
                  }}
                  slotProps={{
                    textField: {
                      fullWidth: true,
                      required: true,
                      error: formik.touched.birthDate && Boolean(formik.errors.birthDate),
                      helperText: formik.touched.birthDate && formik.errors.birthDate,
                      InputProps: {
                        startAdornment: (
                          <InputAdornment position="start">
                            <CakeIcon color="primary" fontSize="small" />
                          </InputAdornment>
                        ),
                      }
                    }
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <FormControl
                  fullWidth
                  required
                  error={formik.touched.gender && Boolean(formik.errors.gender)}
                >
                  <Typography
                    variant="body2"
                    color="text.secondary"
                    sx={{ mb: 1 }}
                  >
                    ××™×Ÿ
                  </Typography>
                  <RadioGroup
                    row
                    aria-labelledby="gender-radio-group-label"
                    name="gender"
                    value={formik.values.gender}
                    onChange={formik.handleChange}
                  >
                    <FormControlLabel
                      value="×–×›×¨"
                      control={
                        <Radio
                          icon={<MaleIcon color="action" />}
                          checkedIcon={<MaleIcon color="primary" />}
                        />
                      }
                      label="×–×›×¨"
                    />
                    <FormControlLabel
                      value="× ×§×‘×”"
                      control={
                        <Radio
                          icon={<FemaleIcon color="action" />}
                          checkedIcon={<FemaleIcon color="primary" />}
                        />
                      }
                      label="× ×§×‘×”"
                    />
                  </RadioGroup>
                  {formik.touched.gender && formik.errors.gender && (
                    <FormHelperText>{formik.errors.gender}</FormHelperText>
                  )}
                </FormControl>
              </Grid>
              <Grid item xs={12} sm={6}>
                <FormControl
                  fullWidth
                  error={
                    formik.touched.cityName && Boolean(formik.errors.cityName)
                  }
                  required
                >
                  <InputLabel id="cityName-label">×¢×™×¨</InputLabel>
                  <Select
                    labelId="cityName-label"
                    id="cityName"
                    name="cityName"
                    value={formik.values.cityName}
                    onChange={formik.handleChange}
                    onBlur={formik.handleBlur}
                    label="×¢×™×¨"
                    startAdornment={
                      <InputAdornment position="start">
                        <CityIcon color="primary" fontSize="small" />
                      </InputAdornment>
                    }
                  >
                    {citiesStatus === "loading" ? (
                      <MenuItem value="">
                        <CircularProgress size={20} />
                        ×˜×•×¢×Ÿ ×¢×¨×™×...
                      </MenuItem>
                    ) : (
                      
                      cities.map((city) => (
                        <MenuItem key={city.id || city.name} value={city.cityName}>
                          {city.cityName}
                        </MenuItem>
                      ))
                    )}
                  </Select>
                  {formik.touched.cityName && formik.errors.cityName && (
                    <FormHelperText>{formik.errors.cityName}</FormHelperText>
                  )}
                </FormControl>
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="address"
                  name="address"
                  label="×›×ª×•×‘×ª"
                  placeholder="×¨×—×•×‘, ××¡×¤×¨ ×‘×™×ª, ×©×›×•× ×”"
                  value={formik.values.address}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={
                    formik.touched.address && Boolean(formik.errors.address)
                  }
                  helperText={formik.touched.address && formik.errors.address}
                  required
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <HomeIcon color="primary" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <FormControl
                  fullWidth
                  error={formik.touched.hName && Boolean(formik.errors.hName)}
                  required
                >
                  <InputLabel id="hName-label">×§×•×¤×ª ×—×•×œ×™×</InputLabel>
                  <Select
                    labelId="hName-label"
                    id="hName"
                    name="hName"
                    value={formik.values.hName}
                    onChange={formik.handleChange}
                    onBlur={formik.handleBlur}
                    label="×§×•×¤×ª ×—×•×œ×™×"
                    startAdornment={
                      <InputAdornment position="start">
                        <HospitalIcon color="primary" fontSize="small" />
                      </InputAdornment>
                    }
                  >
                    {healthInsurances.map((insurance) => (
                      <MenuItem key={insurance.hName} value={insurance.hName}>
                        {insurance.hName}
                      </MenuItem>
                    ))}
                  </Select>
                  {formik.touched.hName && formik.errors.hName && (
                    <FormHelperText>{formik.errors.hName}</FormHelperText>
                  )}
                </FormControl>
              </Grid>



              {/* ×©×“×” ×œ×‘×—×™×¨×ª ×›×™×ª×” ×× ×§×™×™× ××™×“×¢ ×”×›×™×ª×•×ª */}
              {classes && classes.length > 0 && (
                <Grid item xs={12} sm={6}>
                  <FormControl fullWidth>
                    <InputLabel id="classId-label">×›×™×ª×”</InputLabel>
                    <Select
                      labelId="classId-label"
                      id="classId"
                      name="classId"
                      value={formik.values.classId}
                      onChange={formik.handleChange}
                      label="×›×™×ª×”"
                      startAdornment={
                        <InputAdornment position="start">
                          <SchoolIcon color="primary" fontSize="small" />
                        </InputAdornment>
                      }
                    >
                      {classes.map((classItem) => (
                        <MenuItem key={classItem.classId} value={classItem.classId}>
                          {classItem.className}
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>
              )}

              {/* ××ª×’ ×¡×˜×˜×•×¡ ×¤×¢×™×œ */}
              <Grid item xs={12}>
                <FormControlLabel
                  control={
                    <Switch
                      id="isActive"
                      name="isActive"
                      checked={formik.values.isActive}
                      onChange={formik.handleChange}
                      color="success"
                    />
                  }
                  label={
                    <Typography
                      variant="body2"
                      color={
                        formik.values.isActive
                          ? "success.main"
                          : "text.secondary"
                      }
                    >
                      {formik.values.isActive
                        ? "×¤×¢×™×œ ×‘××¢×¨×›×ª"
                        : "×œ× ×¤×¢×™×œ ×‘××¢×¨×›×ª"}
                    </Typography>
                  }
                />
              </Grid>
            </Grid>
          </CardContent>
        </Collapse>
      </AnimatedSection>

      {/* ×§×˜×¢ 2: ×¤×¨×˜×™ ×”×•×¨×” ×¨××©×™ */}
      <AnimatedSection expanded={expandedSections.primaryParent}>
        <SectionHeader onClick={() => toggleSection("primaryParent")}>
          <SectionIcon expanded={expandedSections.primaryParent}>
            <PersonIcon />
          </SectionIcon>
          <SectionTitle variant="h6" expanded={expandedSections.primaryParent}>
            ×¤×¨×˜×™ ×”×•×¨×” ×¨××©×™
            <Chip
              label="×¤×¨×˜×™× ×‘×¡×™×¡×™×™×"
              size="small"
              color={expandedSections.primaryParent ? "primary" : "default"}
              sx={{ ml: 1, fontSize: "0.75rem" }}
            />
          </SectionTitle>
          <Box sx={{ ml: "auto" }}>
            <IconButton
              size="small"
              color={expandedSections.primaryParent ? "primary" : "default"}
              sx={{
                transform: expandedSections.primaryParent
                  ? "rotate(-90deg)"
                  : "rotate(0deg)",
                transition: "transform 0.3s ease",
              }}
            >
              <NextIcon />
            </IconButton>
          </Box>
        </SectionHeader>

        <Collapse in={expandedSections.primaryParent}>
          <CardContent>
            <Grid container spacing={3}>
              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="parent1FirstName"
                  name="parent1FirstName"
                  label="×©× ×¤×¨×˜×™"
                  placeholder="×©× ×¤×¨×˜×™ ×”×”×•×¨×”"
                  value={formik.values.parent1FirstName}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={
                    formik.touched.parent1FirstName &&
                    Boolean(formik.errors.parent1FirstName)
                  }
                  helperText={
                    formik.touched.parent1FirstName &&
                    formik.errors.parent1FirstName
                  }
                  required
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <PersonIcon color="secondary" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="parent1LastName"
                  name="parent1LastName"
                  label="×©× ××©×¤×—×”"
                  placeholder="×©× ××©×¤×—×” ×”×”×•×¨×”"
                  value={formik.values.parent1LastName}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={
                    formik.touched.parent1LastName &&
                    Boolean(formik.errors.parent1LastName)
                  }
                  helperText={
                    formik.touched.parent1LastName &&
                    formik.errors.parent1LastName
                  }
                  required
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <PersonIcon color="secondary" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="parent1Mobile"
                  name="parent1Mobile"
                  label="×˜×œ×¤×•×Ÿ × ×™×™×“"
                  placeholder="05X-XXXXXXX"
                  value={formik.values.parent1Mobile}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={
                    formik.touched.parent1Mobile &&
                    Boolean(formik.errors.parent1Mobile)
                  }
                  helperText={
                    formik.touched.parent1Mobile && formik.errors.parent1Mobile
                  }
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <CallIcon color="secondary" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  required
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="parent1Email"
                  name="parent1Email"
                  label="×“×•××´×œ"
                  type="email"
                  placeholder="example@mail.com"
                  value={formik.values.parent1Email}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={
                    formik.touched.parent1Email &&
                    Boolean(formik.errors.parent1Email)
                  }
                  helperText={
                    formik.touched.parent1Email && formik.errors.parent1Email
                  }
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <EmailIcon color="secondary" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="parent1Address"
                  name="parent1Address"
                  label="×›×ª×•×‘×ª (×× ×©×•× ×” ××›×ª×•×‘×ª ×”×™×œ×“)"
                  placeholder="×¨×—×•×‘, ××¡×¤×¨ ×‘×™×ª, ×©×›×•× ×”"
                  value={formik.values.parent1Address}
                  onChange={formik.handleChange}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <HomeIcon color="secondary" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <FormControl fullWidth>
                  <InputLabel id="parent1CityName-label">×¢×™×¨ ×”×•×¨×”</InputLabel>
                  <Select
                    labelId="parent1CityName-label"
                    id="parent1CityName"
                    name="parent1CityName"
                    value={formik.values.parent1CityName}
                    onChange={formik.handleChange}
                    label="×¢×™×¨ ×”×•×¨×”"
                    startAdornment={
                      <InputAdornment position="start">
                        <CityIcon color="secondary" fontSize="small" />
                      </InputAdornment>
                    }
                  >
                    <MenuItem value="">
                      <em>×–×”×” ×œ×¢×™×¨ ×”×™×œ×“</em>
                    </MenuItem>
                    {citiesStatus === "loading" ? (
                      <MenuItem value="" disabled>
                        <CircularProgress size={20} />
                        ×˜×•×¢×Ÿ ×¢×¨×™×...
                      </MenuItem>
                    ) : (
                      cities.map((city) => (
                        <MenuItem key={city.id || city.name} value={city.name}>
                          {city.name}
                        </MenuItem>
                      ))
                    )}
                  </Select>
                </FormControl>
              </Grid>
            </Grid>
          </CardContent>
        </Collapse>
      </AnimatedSection>

      {/* ×—×œ×§ 3: ×¤×¨×˜×™ ×”×•×¨×” ××©× ×™ (××•×¤×¦×™×•× ×œ×™) */}
      <AnimatedSection expanded={expandedSections.secondaryParent}>
        <SectionHeader onClick={() => toggleSection("secondaryParent")}>
          <SectionIcon expanded={expandedSections.secondaryParent}>
            <PersonAddIcon />
          </SectionIcon>
          <SectionTitle
            variant="h6"
            expanded={expandedSections.secondaryParent}
          >
            ×¤×¨×˜×™ ×”×•×¨×” ××©× ×™
            <Chip
              label="××•×¤×¦×™×•× ×œ×™"
              size="small"
              color={expandedSections.secondaryParent ? "info" : "default"}
              sx={{ ml: 1, fontSize: "0.75rem" }}
            />
          </SectionTitle>
          <Tooltip title="×¤×¨×˜×™ ×”×•×¨×” ××©× ×™ ××™× × ×—×•×‘×” ××š ××•××œ×¦×™× ×œ××™×œ×•×™">
            <InfoIcon
              fontSize="small"
              sx={{ mx: 1, color: theme.palette.info.main }}
            />
          </Tooltip>
          <Box sx={{ ml: "auto" }}>
            <IconButton
              size="small"
              color={expandedSections.secondaryParent ? "primary" : "default"}
              sx={{
                transform: expandedSections.secondaryParent
                  ? "rotate(-90deg)"
                  : "rotate(0deg)",
                transition: "transform 0.3s ease",
              }}
            >
              <NextIcon />
            </IconButton>
          </Box>
        </SectionHeader>

        <Collapse in={expandedSections.secondaryParent}>
          <CardContent>
            <Grid container spacing={3}>
              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="parent2FirstName"
                  name="parent2FirstName"
                  label="×©× ×¤×¨×˜×™"
                  placeholder="×©× ×¤×¨×˜×™ ×”×”×•×¨×”"
                  value={formik.values.parent2FirstName}
                  onChange={formik.handleChange}
                  error={
                    formik.touched.parent2FirstName &&
                    Boolean(formik.errors.parent2FirstName)
                  }
                  helperText={
                    formik.touched.parent2FirstName &&
                    formik.errors.parent2FirstName
                  }
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <PersonIcon color="info" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="parent2LastName"
                  name="parent2LastName"
                  label="×©× ××©×¤×—×”"
                  placeholder="×©× ××©×¤×—×” ×”×”×•×¨×”"
                  value={formik.values.parent2LastName}
                  onChange={formik.handleChange}
                  error={
                    formik.touched.parent2LastName &&
                    Boolean(formik.errors.parent2LastName)
                  }
                  helperText={
                    formik.touched.parent2LastName &&
                    formik.errors.parent2LastName
                  }
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <PersonIcon color="info" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="parent2Mobile"
                  name="parent2Mobile"
                  label="×˜×œ×¤×•×Ÿ × ×™×™×“"
                  placeholder="05X-XXXXXXX"
                  value={formik.values.parent2Mobile}
                  onChange={formik.handleChange}
                  error={
                    formik.touched.parent2Mobile &&
                    Boolean(formik.errors.parent2Mobile)
                  }
                  helperText={
                    formik.touched.parent2Mobile && formik.errors.parent2Mobile
                  }
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <CallIcon color="info" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="parent2Email"
                  name="parent2Email"
                  label="×“×•××´×œ"
                  type="email"
                  placeholder="example@mail.com"
                  value={formik.values.parent2Email}
                  onChange={formik.handleChange}
                  error={
                    formik.touched.parent2Email &&
                    Boolean(formik.errors.parent2Email)
                  }
                  helperText={
                    formik.touched.parent2Email && formik.errors.parent2Email
                  }
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <EmailIcon color="info" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="parent2Address"
                  name="parent2Address"
                  label="×›×ª×•×‘×ª (×× ×©×•× ×” ××›×ª×•×‘×ª ×”×™×œ×“)"
                  placeholder="×¨×—×•×‘, ××¡×¤×¨ ×‘×™×ª, ×©×›×•× ×”"
                  value={formik.values.parent2Address}
                  onChange={formik.handleChange}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <HomeIcon color="info" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <FormControl fullWidth>
                  <InputLabel id="parent2CityName-label">×¢×™×¨ ×”×•×¨×”</InputLabel>
                  <Select
                    labelId="parent2CityName-label"
                    id="parent2CityName"
                    name="parent2CityName"
                    value={formik.values.parent2CityName}
                    onChange={formik.handleChange}
                    label="×¢×™×¨ ×”×•×¨×”"
                    startAdornment={
                      <InputAdornment position="start">
                        <CityIcon color="info" fontSize="small" />
                      </InputAdornment>
                    }
                  >
                    <MenuItem value="">
                      <em>×–×”×” ×œ×¢×™×¨ ×”×™×œ×“</em>
                    </MenuItem>
                    {citiesStatus === "loading" ? (
                      <MenuItem value="" disabled>
                        <CircularProgress size={20} />
                        ×˜×•×¢×Ÿ ×¢×¨×™×...
                      </MenuItem>
                    ) : (
                      cities.map((city) => (
                        <MenuItem key={city.id || city.name} value={city.name}>
                          {city.name}
                        </MenuItem>
                      ))
                    )}
                  </Select>
                </FormControl>
              </Grid>
            </Grid>
          </CardContent>
        </Collapse>
      </AnimatedSection>

      {/* ×—×œ×§ 4: ×¤×¨×˜×™ ×§×©×¨ × ×•×¡×¤×™×
      <AnimatedSection expanded={expandedSections.contactInfo}>
        <SectionHeader onClick={() => toggleSection("contactInfo")}>
          <SectionIcon expanded={expandedSections.contactInfo}>
            <PhoneIcon />
          </SectionIcon>
          <SectionTitle variant="h6" expanded={expandedSections.contactInfo}>
            ×¤×¨×˜×™ ×§×©×¨ × ×•×¡×¤×™×
            <Chip
              label="×—×©×•×‘ ×œ××™×œ×•×™"
              size="small"
              color={expandedSections.contactInfo ? "warning" : "default"}
              sx={{ ml: 1, fontSize: "0.75rem" }}
            />
          </SectionTitle>
          <Box sx={{ ml: "auto" }}>
            <IconButton
              size="small"
              color={expandedSections.contactInfo ? "primary" : "default"}
              sx={{
                transform: expandedSections.contactInfo
                  ? "rotate(-90deg)"
                  : "rotate(0deg)",
                transition: "transform 0.3s ease",
              }}
            >
              <NextIcon />
            </IconButton>
          </Box>
        </SectionHeader>

        <Collapse in={expandedSections.contactInfo}>
          <CardContent>
            <Grid container spacing={3}>
              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="homePhone"
                  name="homePhone"
                  label="×˜×œ×¤×•×Ÿ ×‘×‘×™×ª"
                  placeholder="0X-XXXXXXX"
                  value={formik.values.homePhone}
                  onChange={formik.handleChange}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <CallIcon color="warning" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="emergencyContactName"
                  name="emergencyContactName"
                  label="××™×© ×§×©×¨ ×‘×©×¢×ª ×—×™×¨×•×"
                  placeholder="×©× ××œ×"
                  value={formik.values.emergencyContactName}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={
                    formik.touched.emergencyContactName &&
                    Boolean(formik.errors.emergencyContactName)
                  }
                  helperText={
                    formik.touched.emergencyContactName &&
                    formik.errors.emergencyContactName
                  }
                  required
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <PersonIcon color="error" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="emergencyContactPhone"
                  name="emergencyContactPhone"
                  label="×˜×œ×¤×•×Ÿ ××™×© ×§×©×¨ ×—×™×¨×•×"
                  placeholder="0X-XXXXXXX"
                  value={formik.values.emergencyContactPhone}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={
                    formik.touched.emergencyContactPhone &&
                    Boolean(formik.errors.emergencyContactPhone)
                  }
                  helperText={
                    formik.touched.emergencyContactPhone &&
                    formik.errors.emergencyContactPhone
                  }
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <CallIcon color="error" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  required
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  id="socialWorker"
                  name="socialWorker"
                  label="×¢×•×‘×“ ×¡×•×¦×™××œ×™"
                  placeholder="×©× ×”×¢×•×‘×“ ×”×¡×•×¦×™××œ×™"
                  value={formik.values.socialWorker}
                  onChange={formik.handleChange}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <MedicalIcon color="warning" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <DatePicker
                  label="×ª××¨×™×š ×”×¤× ×™×”"
                  value={formik.values.referralDate}
                  onChange={(date) =>
                    formik.setFieldValue("referralDate", date)
                  }
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      id="referralDate"
                      name="referralDate"
                      fullWidth
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <EventIcon color="warning" fontSize="small" />
                          </InputAdornment>
                        ),
                      }}
                    />
                  )}
                />
              </Grid>

              <Grid item xs={12} sm={6}>
                <DatePicker
                  label="×ª××¨×™×š ×›× ×™×¡×” ××ª×•×›× ×Ÿ"
                  value={formik.values.plannedEntryDate}
                  onChange={(date) =>
                    formik.setFieldValue("plannedEntryDate", date)
                  }
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      id="plannedEntryDate"
                      name="plannedEntryDate"
                      fullWidth
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <EventIcon color="warning" fontSize="small" />
                          </InputAdornment>
                        ),
                      }}
                    />
                  )}
                />
              </Grid>
            </Grid>
          </CardContent>
        </Collapse>
      </AnimatedSection> */}

      {/* ×¡×™×›×•× ×•×”×©×œ××” */}
      <Box sx={{ mt: 2, mb: 2 }}>
        <Alert
          severity={isFormFilled ? "info" : "warning"}
          variant="outlined"
          sx={{ borderRadius: 2 }}
          icon={isFormFilled ? <InfoIcon /> : <InfoIcon />}
        >
          <AlertTitle>
            {isFormFilled ? "×”×˜×•×¤×¡ ××•×›×Ÿ ×œ×©××™×¨×”" : "×™×© ×œ×”×©×œ×™× ××ª ×”×˜×•×¤×¡"}
          </AlertTitle>
          {isFormFilled
            ? "×”×©×œ××ª ××ª ××™×œ×•×™ ×”×˜×•×¤×¡. ×œ××—×¨ ×©××™×¨×” ×ª×•×¢×‘×¨ ×œ×©×œ×‘ ×”×‘× ×‘×ª×”×œ×™×š ×§×œ×™×˜×ª ×”×™×œ×“."
            : "×™×© ×œ××œ× ××ª ×›×œ ×©×“×•×ª ×”×—×•×‘×” (××¡×•×× ×™× ×‘-*) ×œ×¤× ×™ ×”××©×š ×”×ª×”×œ×™×š."}
        </Alert>
      </Box>

      {/* ×›×¤×ª×•×¨×™ ×¤×¢×•×œ×” ×‘×ª×—×ª×™×ª ×”×˜×•×¤×¡ */}
      <Paper
        elevation={3}
        sx={{
          borderRadius: 2,
          overflow: "hidden",
          mt: 4,
        }}
      >
        <ActionButtonsContainer>
          <AnimatedButton
            variant="outlined"
            color="error"
            onClick={() => {
              Swal.fire({
                title: "×”×× ××ª×” ×‘×˜×•×—?",
                text: "×”×¤×¢×•×œ×” ×ª× ×§×” ××ª ×›×œ ×”×©×“×•×ª!",
                icon: "warning",
                showCancelButton: true,
                confirmButtonText: "×›×Ÿ, × ×§×” ×˜×•×¤×¡",
                cancelButtonText: "×‘×™×˜×•×œ",
                reverseButtons: true,
              }).then((result) => {
                if (result.isConfirmed) {
                  formik.resetForm();
                  Swal.fire({
                    title: "× ×•×§×”!",
                    text: "×”×˜×•×¤×¡ × ×•×§×” ×‘×”×¦×œ×—×”.",
                    icon: "success",
                    timer: 1000,
                    showConfirmButton: false,
                  });
                }
              });
            }}
            startIcon={<DeleteIcon />}
            disabled={isLoading}
            sx={{ borderRadius: "50px", px: 3 }}
          >
            × ×§×” ×˜×•×¤×¡
          </AnimatedButton>

          <Box>
            <AnimatedButton
              type="submit"
              variant="contained"
              color="primary"
              startIcon={
                isLoading ? (
                  <CircularProgress size={20} color="inherit" />
                ) : isEditMode ? (
                  <EditIcon />
                ) : (
                  <SaveIcon />
                )
              }
              // disabled={isLoading}
              sx={{
                borderRadius: "50px",
                px: 4,
                background: "linear-gradient(45deg, #2196F3 30%, #21CBF3 90%)",
                boxShadow: "0 3px 5px 2px rgba(33, 203, 243, .3)",
              }}
            >
              {isEditMode ? "×¢×“×›×Ÿ ×¤×¨×˜×™×" : "×©××•×¨ ×¤×¨×˜×™× ×•×”××©×š"}
            </AnimatedButton>
          </Box>
        </ActionButtonsContainer>
      </Paper>
    </form>
  );
};

export default PersonalInfoForm;